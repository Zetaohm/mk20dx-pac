# [doc = "Register `MSC` reader"] pub type R = crate :: R < MscSpec > ; # [doc = "Register `MSC` writer"] pub type W = crate :: W < MscSpec > ; # [doc = "Modulator and Carrier Generator Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mcgen { # [doc = "0: Modulator and carrier generator disabled"] _0 = 0 , # [doc = "1: Modulator and carrier generator enabled"] _1 = 1 , } impl From < Mcgen > for bool { # [inline (always)] fn from (variant : Mcgen) -> Self { variant as u8 != 0 } } # [doc = "Field `MCGEN` reader - Modulator and Carrier Generator Enable"] pub type McgenR = crate :: BitReader < Mcgen > ; impl McgenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mcgen { match self . bits { false => Mcgen :: _0 , true => Mcgen :: _1 , } } # [doc = "Modulator and carrier generator disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Mcgen :: _0 } # [doc = "Modulator and carrier generator enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Mcgen :: _1 } } # [doc = "Field `MCGEN` writer - Modulator and Carrier Generator Enable"] pub type McgenW < 'a , REG > = crate :: BitWriter < 'a , REG , Mcgen > ; impl < 'a , REG > McgenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Modulator and carrier generator disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mcgen :: _0) } # [doc = "Modulator and carrier generator enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mcgen :: _1) } } # [doc = "End of Cycle Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eocie { # [doc = "0: CPU interrupt disabled"] _0 = 0 , # [doc = "1: CPU interrupt enabled"] _1 = 1 , } impl From < Eocie > for bool { # [inline (always)] fn from (variant : Eocie) -> Self { variant as u8 != 0 } } # [doc = "Field `EOCIE` reader - End of Cycle Interrupt Enable"] pub type EocieR = crate :: BitReader < Eocie > ; impl EocieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eocie { match self . bits { false => Eocie :: _0 , true => Eocie :: _1 , } } # [doc = "CPU interrupt disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Eocie :: _0 } # [doc = "CPU interrupt enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Eocie :: _1 } } # [doc = "Field `EOCIE` writer - End of Cycle Interrupt Enable"] pub type EocieW < 'a , REG > = crate :: BitWriter < 'a , REG , Eocie > ; impl < 'a , REG > EocieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CPU interrupt disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Eocie :: _0) } # [doc = "CPU interrupt enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Eocie :: _1) } } # [doc = "FSK Mode Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fsk { # [doc = "0: CMT operates in Time or Baseband mode"] _0 = 0 , # [doc = "1: CMT operates in FSK mode"] _1 = 1 , } impl From < Fsk > for bool { # [inline (always)] fn from (variant : Fsk) -> Self { variant as u8 != 0 } } # [doc = "Field `FSK` reader - FSK Mode Select"] pub type FskR = crate :: BitReader < Fsk > ; impl FskR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fsk { match self . bits { false => Fsk :: _0 , true => Fsk :: _1 , } } # [doc = "CMT operates in Time or Baseband mode"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Fsk :: _0 } # [doc = "CMT operates in FSK mode"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Fsk :: _1 } } # [doc = "Field `FSK` writer - FSK Mode Select"] pub type FskW < 'a , REG > = crate :: BitWriter < 'a , REG , Fsk > ; impl < 'a , REG > FskW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CMT operates in Time or Baseband mode"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Fsk :: _0) } # [doc = "CMT operates in FSK mode"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Fsk :: _1) } } # [doc = "Baseband Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Base { # [doc = "0: Baseband mode disabled"] _0 = 0 , # [doc = "1: Baseband mode enabled"] _1 = 1 , } impl From < Base > for bool { # [inline (always)] fn from (variant : Base) -> Self { variant as u8 != 0 } } # [doc = "Field `BASE` reader - Baseband Enable"] pub type BaseR = crate :: BitReader < Base > ; impl BaseR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Base { match self . bits { false => Base :: _0 , true => Base :: _1 , } } # [doc = "Baseband mode disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Base :: _0 } # [doc = "Baseband mode enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Base :: _1 } } # [doc = "Field `BASE` writer - Baseband Enable"] pub type BaseW < 'a , REG > = crate :: BitWriter < 'a , REG , Base > ; impl < 'a , REG > BaseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Baseband mode disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Base :: _0) } # [doc = "Baseband mode enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Base :: _1) } } # [doc = "Extended Space Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Exspc { # [doc = "0: Extended space disabled"] _0 = 0 , # [doc = "1: Extended space enabled"] _1 = 1 , } impl From < Exspc > for bool { # [inline (always)] fn from (variant : Exspc) -> Self { variant as u8 != 0 } } # [doc = "Field `EXSPC` reader - Extended Space Enable"] pub type ExspcR = crate :: BitReader < Exspc > ; impl ExspcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Exspc { match self . bits { false => Exspc :: _0 , true => Exspc :: _1 , } } # [doc = "Extended space disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Exspc :: _0 } # [doc = "Extended space enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Exspc :: _1 } } # [doc = "Field `EXSPC` writer - Extended Space Enable"] pub type ExspcW < 'a , REG > = crate :: BitWriter < 'a , REG , Exspc > ; impl < 'a , REG > ExspcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Extended space disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Exspc :: _0) } # [doc = "Extended space enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Exspc :: _1) } } # [doc = "CMT Clock Divide Prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Cmtdiv { # [doc = "0: IF * 1"] _00 = 0 , # [doc = "1: IF * 2"] _01 = 1 , # [doc = "2: IF * 4"] _10 = 2 , # [doc = "3: IF * 8"] _11 = 3 , } impl From < Cmtdiv > for u8 { # [inline (always)] fn from (variant : Cmtdiv) -> Self { variant as _ } } impl crate :: FieldSpec for Cmtdiv { type Ux = u8 ; } impl crate :: IsEnum for Cmtdiv { } # [doc = "Field `CMTDIV` reader - CMT Clock Divide Prescaler"] pub type CmtdivR = crate :: FieldReader < Cmtdiv > ; impl CmtdivR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cmtdiv { match self . bits { 0 => Cmtdiv :: _00 , 1 => Cmtdiv :: _01 , 2 => Cmtdiv :: _10 , 3 => Cmtdiv :: _11 , _ => unreachable ! () , } } # [doc = "IF * 1"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Cmtdiv :: _00 } # [doc = "IF * 2"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Cmtdiv :: _01 } # [doc = "IF * 4"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Cmtdiv :: _10 } # [doc = "IF * 8"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == Cmtdiv :: _11 } } # [doc = "Field `CMTDIV` writer - CMT Clock Divide Prescaler"] pub type CmtdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Cmtdiv , crate :: Safe > ; impl < 'a , REG > CmtdivW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "IF * 1"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Cmtdiv :: _00) } # [doc = "IF * 2"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Cmtdiv :: _01) } # [doc = "IF * 4"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Cmtdiv :: _10) } # [doc = "IF * 8"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Cmtdiv :: _11) } } # [doc = "End Of Cycle Status Flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eocf { # [doc = "0: No end of modulation cycle occurrence since flag last cleared"] _0 = 0 , # [doc = "1: End of modulator cycle has occurred"] _1 = 1 , } impl From < Eocf > for bool { # [inline (always)] fn from (variant : Eocf) -> Self { variant as u8 != 0 } } # [doc = "Field `EOCF` reader - End Of Cycle Status Flag"] pub type EocfR = crate :: BitReader < Eocf > ; impl EocfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eocf { match self . bits { false => Eocf :: _0 , true => Eocf :: _1 , } } # [doc = "No end of modulation cycle occurrence since flag last cleared"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Eocf :: _0 } # [doc = "End of modulator cycle has occurred"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Eocf :: _1 } } impl R { # [doc = "Bit 0 - Modulator and Carrier Generator Enable"] # [inline (always)] pub fn mcgen (& self) -> McgenR { McgenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - End of Cycle Interrupt Enable"] # [inline (always)] pub fn eocie (& self) -> EocieR { EocieR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - FSK Mode Select"] # [inline (always)] pub fn fsk (& self) -> FskR { FskR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Baseband Enable"] # [inline (always)] pub fn base (& self) -> BaseR { BaseR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Extended Space Enable"] # [inline (always)] pub fn exspc (& self) -> ExspcR { ExspcR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - CMT Clock Divide Prescaler"] # [inline (always)] pub fn cmtdiv (& self) -> CmtdivR { CmtdivR :: new ((self . bits >> 5) & 3) } # [doc = "Bit 7 - End Of Cycle Status Flag"] # [inline (always)] pub fn eocf (& self) -> EocfR { EocfR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Modulator and Carrier Generator Enable"] # [inline (always)] # [must_use] pub fn mcgen (& mut self) -> McgenW < MscSpec > { McgenW :: new (self , 0) } # [doc = "Bit 1 - End of Cycle Interrupt Enable"] # [inline (always)] # [must_use] pub fn eocie (& mut self) -> EocieW < MscSpec > { EocieW :: new (self , 1) } # [doc = "Bit 2 - FSK Mode Select"] # [inline (always)] # [must_use] pub fn fsk (& mut self) -> FskW < MscSpec > { FskW :: new (self , 2) } # [doc = "Bit 3 - Baseband Enable"] # [inline (always)] # [must_use] pub fn base (& mut self) -> BaseW < MscSpec > { BaseW :: new (self , 3) } # [doc = "Bit 4 - Extended Space Enable"] # [inline (always)] # [must_use] pub fn exspc (& mut self) -> ExspcW < MscSpec > { ExspcW :: new (self , 4) } # [doc = "Bits 5:6 - CMT Clock Divide Prescaler"] # [inline (always)] # [must_use] pub fn cmtdiv (& mut self) -> CmtdivW < MscSpec > { CmtdivW :: new (self , 5) } } # [doc = "CMT Modulator Status and Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`msc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`msc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MscSpec ; impl crate :: RegisterSpec for MscSpec { type Ux = u8 ; } # [doc = "`read()` method returns [`msc::R`](R) reader structure"] impl crate :: Readable for MscSpec { } # [doc = "`write(|w| ..)` method takes [`msc::W`](W) writer structure"] impl crate :: Writable for MscSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets MSC to value 0"] impl crate :: Resettable for MscSpec { const RESET_VALUE : u8 = 0 ; }