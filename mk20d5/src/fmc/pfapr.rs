# [doc = "Register `PFAPR` reader"] pub type R = crate :: R < PfaprSpec > ; # [doc = "Register `PFAPR` writer"] pub type W = crate :: W < PfaprSpec > ; # [doc = "Master 0 Access Protection\n\nValue on reset: 3"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum M0ap { # [doc = "0: No access may be performed by this master"] _00 = 0 , # [doc = "1: Only read accesses may be performed by this master"] _01 = 1 , # [doc = "2: Only write accesses may be performed by this master"] _10 = 2 , # [doc = "3: Both read and write accesses may be performed by this master"] _11 = 3 , } impl From < M0ap > for u8 { # [inline (always)] fn from (variant : M0ap) -> Self { variant as _ } } impl crate :: FieldSpec for M0ap { type Ux = u8 ; } impl crate :: IsEnum for M0ap { } # [doc = "Field `M0AP` reader - Master 0 Access Protection"] pub type M0apR = crate :: FieldReader < M0ap > ; impl M0apR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M0ap { match self . bits { 0 => M0ap :: _00 , 1 => M0ap :: _01 , 2 => M0ap :: _10 , 3 => M0ap :: _11 , _ => unreachable ! () , } } # [doc = "No access may be performed by this master"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == M0ap :: _00 } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == M0ap :: _01 } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == M0ap :: _10 } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == M0ap :: _11 } } # [doc = "Field `M0AP` writer - Master 0 Access Protection"] pub type M0apW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , M0ap , crate :: Safe > ; impl < 'a , REG > M0apW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No access may be performed by this master"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (M0ap :: _00) } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (M0ap :: _01) } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (M0ap :: _10) } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (M0ap :: _11) } } # [doc = "Master 1 Access Protection\n\nValue on reset: 3"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum M1ap { # [doc = "0: No access may be performed by this master"] _00 = 0 , # [doc = "1: Only read accesses may be performed by this master"] _01 = 1 , # [doc = "2: Only write accesses may be performed by this master"] _10 = 2 , # [doc = "3: Both read and write accesses may be performed by this master"] _11 = 3 , } impl From < M1ap > for u8 { # [inline (always)] fn from (variant : M1ap) -> Self { variant as _ } } impl crate :: FieldSpec for M1ap { type Ux = u8 ; } impl crate :: IsEnum for M1ap { } # [doc = "Field `M1AP` reader - Master 1 Access Protection"] pub type M1apR = crate :: FieldReader < M1ap > ; impl M1apR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M1ap { match self . bits { 0 => M1ap :: _00 , 1 => M1ap :: _01 , 2 => M1ap :: _10 , 3 => M1ap :: _11 , _ => unreachable ! () , } } # [doc = "No access may be performed by this master"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == M1ap :: _00 } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == M1ap :: _01 } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == M1ap :: _10 } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == M1ap :: _11 } } # [doc = "Field `M1AP` writer - Master 1 Access Protection"] pub type M1apW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , M1ap , crate :: Safe > ; impl < 'a , REG > M1apW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No access may be performed by this master"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (M1ap :: _00) } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (M1ap :: _01) } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (M1ap :: _10) } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (M1ap :: _11) } } # [doc = "Master 2 Access Protection\n\nValue on reset: 3"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum M2ap { # [doc = "0: No access may be performed by this master"] _00 = 0 , # [doc = "1: Only read accesses may be performed by this master"] _01 = 1 , # [doc = "2: Only write accesses may be performed by this master"] _10 = 2 , # [doc = "3: Both read and write accesses may be performed by this master"] _11 = 3 , } impl From < M2ap > for u8 { # [inline (always)] fn from (variant : M2ap) -> Self { variant as _ } } impl crate :: FieldSpec for M2ap { type Ux = u8 ; } impl crate :: IsEnum for M2ap { } # [doc = "Field `M2AP` reader - Master 2 Access Protection"] pub type M2apR = crate :: FieldReader < M2ap > ; impl M2apR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M2ap { match self . bits { 0 => M2ap :: _00 , 1 => M2ap :: _01 , 2 => M2ap :: _10 , 3 => M2ap :: _11 , _ => unreachable ! () , } } # [doc = "No access may be performed by this master"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == M2ap :: _00 } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == M2ap :: _01 } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == M2ap :: _10 } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == M2ap :: _11 } } # [doc = "Field `M2AP` writer - Master 2 Access Protection"] pub type M2apW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , M2ap , crate :: Safe > ; impl < 'a , REG > M2apW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No access may be performed by this master"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (M2ap :: _00) } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (M2ap :: _01) } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (M2ap :: _10) } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (M2ap :: _11) } } # [doc = "Master 3 Access Protection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum M3ap { # [doc = "0: No access may be performed by this master"] _00 = 0 , # [doc = "1: Only read accesses may be performed by this master"] _01 = 1 , # [doc = "2: Only write accesses may be performed by this master"] _10 = 2 , # [doc = "3: Both read and write accesses may be performed by this master"] _11 = 3 , } impl From < M3ap > for u8 { # [inline (always)] fn from (variant : M3ap) -> Self { variant as _ } } impl crate :: FieldSpec for M3ap { type Ux = u8 ; } impl crate :: IsEnum for M3ap { } # [doc = "Field `M3AP` reader - Master 3 Access Protection"] pub type M3apR = crate :: FieldReader < M3ap > ; impl M3apR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M3ap { match self . bits { 0 => M3ap :: _00 , 1 => M3ap :: _01 , 2 => M3ap :: _10 , 3 => M3ap :: _11 , _ => unreachable ! () , } } # [doc = "No access may be performed by this master"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == M3ap :: _00 } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == M3ap :: _01 } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == M3ap :: _10 } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == M3ap :: _11 } } # [doc = "Field `M3AP` writer - Master 3 Access Protection"] pub type M3apW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , M3ap , crate :: Safe > ; impl < 'a , REG > M3apW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No access may be performed by this master"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (M3ap :: _00) } # [doc = "Only read accesses may be performed by this master"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (M3ap :: _01) } # [doc = "Only write accesses may be performed by this master"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (M3ap :: _10) } # [doc = "Both read and write accesses may be performed by this master"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (M3ap :: _11) } } # [doc = "Master 0 Prefetch Disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum M0pfd { # [doc = "0: Prefetching for this master is enabled."] _0 = 0 , # [doc = "1: Prefetching for this master is disabled."] _1 = 1 , } impl From < M0pfd > for bool { # [inline (always)] fn from (variant : M0pfd) -> Self { variant as u8 != 0 } } # [doc = "Field `M0PFD` reader - Master 0 Prefetch Disable"] pub type M0pfdR = crate :: BitReader < M0pfd > ; impl M0pfdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M0pfd { match self . bits { false => M0pfd :: _0 , true => M0pfd :: _1 , } } # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == M0pfd :: _0 } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == M0pfd :: _1 } } # [doc = "Field `M0PFD` writer - Master 0 Prefetch Disable"] pub type M0pfdW < 'a , REG > = crate :: BitWriter < 'a , REG , M0pfd > ; impl < 'a , REG > M0pfdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (M0pfd :: _0) } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (M0pfd :: _1) } } # [doc = "Master 1 Prefetch Disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum M1pfd { # [doc = "0: Prefetching for this master is enabled."] _0 = 0 , # [doc = "1: Prefetching for this master is disabled."] _1 = 1 , } impl From < M1pfd > for bool { # [inline (always)] fn from (variant : M1pfd) -> Self { variant as u8 != 0 } } # [doc = "Field `M1PFD` reader - Master 1 Prefetch Disable"] pub type M1pfdR = crate :: BitReader < M1pfd > ; impl M1pfdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M1pfd { match self . bits { false => M1pfd :: _0 , true => M1pfd :: _1 , } } # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == M1pfd :: _0 } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == M1pfd :: _1 } } # [doc = "Field `M1PFD` writer - Master 1 Prefetch Disable"] pub type M1pfdW < 'a , REG > = crate :: BitWriter < 'a , REG , M1pfd > ; impl < 'a , REG > M1pfdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (M1pfd :: _0) } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (M1pfd :: _1) } } # [doc = "Master 2 Prefetch Disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum M2pfd { # [doc = "0: Prefetching for this master is enabled."] _0 = 0 , # [doc = "1: Prefetching for this master is disabled."] _1 = 1 , } impl From < M2pfd > for bool { # [inline (always)] fn from (variant : M2pfd) -> Self { variant as u8 != 0 } } # [doc = "Field `M2PFD` reader - Master 2 Prefetch Disable"] pub type M2pfdR = crate :: BitReader < M2pfd > ; impl M2pfdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M2pfd { match self . bits { false => M2pfd :: _0 , true => M2pfd :: _1 , } } # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == M2pfd :: _0 } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == M2pfd :: _1 } } # [doc = "Field `M2PFD` writer - Master 2 Prefetch Disable"] pub type M2pfdW < 'a , REG > = crate :: BitWriter < 'a , REG , M2pfd > ; impl < 'a , REG > M2pfdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (M2pfd :: _0) } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (M2pfd :: _1) } } # [doc = "Master 3 Prefetch Disable\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum M3pfd { # [doc = "0: Prefetching for this master is enabled."] _0 = 0 , # [doc = "1: Prefetching for this master is disabled."] _1 = 1 , } impl From < M3pfd > for bool { # [inline (always)] fn from (variant : M3pfd) -> Self { variant as u8 != 0 } } # [doc = "Field `M3PFD` reader - Master 3 Prefetch Disable"] pub type M3pfdR = crate :: BitReader < M3pfd > ; impl M3pfdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M3pfd { match self . bits { false => M3pfd :: _0 , true => M3pfd :: _1 , } } # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == M3pfd :: _0 } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == M3pfd :: _1 } } # [doc = "Field `M3PFD` writer - Master 3 Prefetch Disable"] pub type M3pfdW < 'a , REG > = crate :: BitWriter < 'a , REG , M3pfd > ; impl < 'a , REG > M3pfdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Prefetching for this master is enabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (M3pfd :: _0) } # [doc = "Prefetching for this master is disabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (M3pfd :: _1) } } impl R { # [doc = "Bits 0:1 - Master 0 Access Protection"] # [inline (always)] pub fn m0ap (& self) -> M0apR { M0apR :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Master 1 Access Protection"] # [inline (always)] pub fn m1ap (& self) -> M1apR { M1apR :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Master 2 Access Protection"] # [inline (always)] pub fn m2ap (& self) -> M2apR { M2apR :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Master 3 Access Protection"] # [inline (always)] pub fn m3ap (& self) -> M3apR { M3apR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 16 - Master 0 Prefetch Disable"] # [inline (always)] pub fn m0pfd (& self) -> M0pfdR { M0pfdR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Master 1 Prefetch Disable"] # [inline (always)] pub fn m1pfd (& self) -> M1pfdR { M1pfdR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Master 2 Prefetch Disable"] # [inline (always)] pub fn m2pfd (& self) -> M2pfdR { M2pfdR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Master 3 Prefetch Disable"] # [inline (always)] pub fn m3pfd (& self) -> M3pfdR { M3pfdR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Master 0 Access Protection"] # [inline (always)] # [must_use] pub fn m0ap (& mut self) -> M0apW < PfaprSpec > { M0apW :: new (self , 0) } # [doc = "Bits 2:3 - Master 1 Access Protection"] # [inline (always)] # [must_use] pub fn m1ap (& mut self) -> M1apW < PfaprSpec > { M1apW :: new (self , 2) } # [doc = "Bits 4:5 - Master 2 Access Protection"] # [inline (always)] # [must_use] pub fn m2ap (& mut self) -> M2apW < PfaprSpec > { M2apW :: new (self , 4) } # [doc = "Bits 6:7 - Master 3 Access Protection"] # [inline (always)] # [must_use] pub fn m3ap (& mut self) -> M3apW < PfaprSpec > { M3apW :: new (self , 6) } # [doc = "Bit 16 - Master 0 Prefetch Disable"] # [inline (always)] # [must_use] pub fn m0pfd (& mut self) -> M0pfdW < PfaprSpec > { M0pfdW :: new (self , 16) } # [doc = "Bit 17 - Master 1 Prefetch Disable"] # [inline (always)] # [must_use] pub fn m1pfd (& mut self) -> M1pfdW < PfaprSpec > { M1pfdW :: new (self , 17) } # [doc = "Bit 18 - Master 2 Prefetch Disable"] # [inline (always)] # [must_use] pub fn m2pfd (& mut self) -> M2pfdW < PfaprSpec > { M2pfdW :: new (self , 18) } # [doc = "Bit 19 - Master 3 Prefetch Disable"] # [inline (always)] # [must_use] pub fn m3pfd (& mut self) -> M3pfdW < PfaprSpec > { M3pfdW :: new (self , 19) } } # [doc = "Flash Access Protection Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pfapr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pfapr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PfaprSpec ; impl crate :: RegisterSpec for PfaprSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pfapr::R`](R) reader structure"] impl crate :: Readable for PfaprSpec { } # [doc = "`write(|w| ..)` method takes [`pfapr::W`](W) writer structure"] impl crate :: Writable for PfaprSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PFAPR to value 0x00f8_003f"] impl crate :: Resettable for PfaprSpec { const RESET_VALUE : u32 = 0x00f8_003f ; }