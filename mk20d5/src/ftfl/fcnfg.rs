# [doc = "Register `FCNFG` reader"] pub type R = crate :: R < FcnfgSpec > ; # [doc = "Register `FCNFG` writer"] pub type W = crate :: W < FcnfgSpec > ; # [doc = "This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eeerdy { # [doc = "0: FlexRAM is not available for EEPROM operation."] _0 = 0 , # [doc = "1: FlexRAM is available for EEPROM operations where: reads from the FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes to the FlexRAM clear EEERDY and launch an EEPROM operation to store the written data in the FlexRAM and EEPROM backup."] _1 = 1 , } impl From < Eeerdy > for bool { # [inline (always)] fn from (variant : Eeerdy) -> Self { variant as u8 != 0 } } # [doc = "Field `EEERDY` reader - This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access"] pub type EeerdyR = crate :: BitReader < Eeerdy > ; impl EeerdyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eeerdy { match self . bits { false => Eeerdy :: _0 , true => Eeerdy :: _1 , } } # [doc = "FlexRAM is not available for EEPROM operation."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Eeerdy :: _0 } # [doc = "FlexRAM is available for EEPROM operations where: reads from the FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes to the FlexRAM clear EEERDY and launch an EEPROM operation to store the written data in the FlexRAM and EEPROM backup."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Eeerdy :: _1 } } # [doc = "RAM Ready\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ramrdy { # [doc = "0: FlexRAM is not available for traditional RAM access."] _0 = 0 , # [doc = "1: FlexRAM is available as traditional RAM only; writes to the FlexRAM do not trigger EEPROM operations."] _1 = 1 , } impl From < Ramrdy > for bool { # [inline (always)] fn from (variant : Ramrdy) -> Self { variant as u8 != 0 } } # [doc = "Field `RAMRDY` reader - RAM Ready"] pub type RamrdyR = crate :: BitReader < Ramrdy > ; impl RamrdyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ramrdy { match self . bits { false => Ramrdy :: _0 , true => Ramrdy :: _1 , } } # [doc = "FlexRAM is not available for traditional RAM access."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ramrdy :: _0 } # [doc = "FlexRAM is available as traditional RAM only; writes to the FlexRAM do not trigger EEPROM operations."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ramrdy :: _1 } } # [doc = "FTFL configuration\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pflsh { # [doc = "0: FTFL configured for FlexMemory that supports data flash and/or EEPROM"] _0 = 0 , } impl From < Pflsh > for bool { # [inline (always)] fn from (variant : Pflsh) -> Self { variant as u8 != 0 } } # [doc = "Field `PFLSH` reader - FTFL configuration"] pub type PflshR = crate :: BitReader < Pflsh > ; impl PflshR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Pflsh > { match self . bits { false => Some (Pflsh :: _0) , _ => None , } } # [doc = "FTFL configured for FlexMemory that supports data flash and/or EEPROM"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pflsh :: _0 } } # [doc = "Erase Suspend\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Erssusp { # [doc = "0: No suspend requested"] _0 = 0 , # [doc = "1: Suspend the current Erase Flash Sector command execution."] _1 = 1 , } impl From < Erssusp > for bool { # [inline (always)] fn from (variant : Erssusp) -> Self { variant as u8 != 0 } } # [doc = "Field `ERSSUSP` reader - Erase Suspend"] pub type ErssuspR = crate :: BitReader < Erssusp > ; impl ErssuspR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Erssusp { match self . bits { false => Erssusp :: _0 , true => Erssusp :: _1 , } } # [doc = "No suspend requested"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Erssusp :: _0 } # [doc = "Suspend the current Erase Flash Sector command execution."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Erssusp :: _1 } } # [doc = "Field `ERSSUSP` writer - Erase Suspend"] pub type ErssuspW < 'a , REG > = crate :: BitWriter < 'a , REG , Erssusp > ; impl < 'a , REG > ErssuspW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No suspend requested"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Erssusp :: _0) } # [doc = "Suspend the current Erase Flash Sector command execution."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Erssusp :: _1) } } # [doc = "Erase All Request\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ersareq { # [doc = "0: No request or request complete"] _0 = 0 , # [doc = "1: Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC\\[SEC\\]
field to the unsecure state."] _1 = 1 , } impl From < Ersareq > for bool { # [inline (always)] fn from (variant : Ersareq) -> Self { variant as u8 != 0 } } # [doc = "Field `ERSAREQ` reader - Erase All Request"] pub type ErsareqR = crate :: BitReader < Ersareq > ; impl ErsareqR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ersareq { match self . bits { false => Ersareq :: _0 , true => Ersareq :: _1 , } } # [doc = "No request or request complete"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ersareq :: _0 } # [doc = "Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC\\[SEC\\]
field to the unsecure state."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ersareq :: _1 } } # [doc = "Read Collision Error Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rdcollie { # [doc = "0: Read collision error interrupt disabled"] _0 = 0 , # [doc = "1: Read collision error interrupt enabled. An interrupt request is generated whenever an FTFL read collision error is detected (see the description of FSTAT\\[RDCOLERR\\])."] _1 = 1 , } impl From < Rdcollie > for bool { # [inline (always)] fn from (variant : Rdcollie) -> Self { variant as u8 != 0 } } # [doc = "Field `RDCOLLIE` reader - Read Collision Error Interrupt Enable"] pub type RdcollieR = crate :: BitReader < Rdcollie > ; impl RdcollieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rdcollie { match self . bits { false => Rdcollie :: _0 , true => Rdcollie :: _1 , } } # [doc = "Read collision error interrupt disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Rdcollie :: _0 } # [doc = "Read collision error interrupt enabled. An interrupt request is generated whenever an FTFL read collision error is detected (see the description of FSTAT\\[RDCOLERR\\])."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Rdcollie :: _1 } } # [doc = "Field `RDCOLLIE` writer - Read Collision Error Interrupt Enable"] pub type RdcollieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rdcollie > ; impl < 'a , REG > RdcollieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Read collision error interrupt disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdcollie :: _0) } # [doc = "Read collision error interrupt enabled. An interrupt request is generated whenever an FTFL read collision error is detected (see the description of FSTAT\\[RDCOLERR\\])."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdcollie :: _1) } } # [doc = "Command Complete Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ccie { # [doc = "0: Command complete interrupt disabled"] _0 = 0 , # [doc = "1: Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT\\[CCIF\\]
flag is set."] _1 = 1 , } impl From < Ccie > for bool { # [inline (always)] fn from (variant : Ccie) -> Self { variant as u8 != 0 } } # [doc = "Field `CCIE` reader - Command Complete Interrupt Enable"] pub type CcieR = crate :: BitReader < Ccie > ; impl CcieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ccie { match self . bits { false => Ccie :: _0 , true => Ccie :: _1 , } } # [doc = "Command complete interrupt disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ccie :: _0 } # [doc = "Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT\\[CCIF\\]
flag is set."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ccie :: _1 } } # [doc = "Field `CCIE` writer - Command Complete Interrupt Enable"] pub type CcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Ccie > ; impl < 'a , REG > CcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Command complete interrupt disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ccie :: _0) } # [doc = "Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT\\[CCIF\\]
flag is set."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ccie :: _1) } } impl R { # [doc = "Bit 0 - This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access"] # [inline (always)] pub fn eeerdy (& self) -> EeerdyR { EeerdyR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - RAM Ready"] # [inline (always)] pub fn ramrdy (& self) -> RamrdyR { RamrdyR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - FTFL configuration"] # [inline (always)] pub fn pflsh (& self) -> PflshR { PflshR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Erase Suspend"] # [inline (always)] pub fn erssusp (& self) -> ErssuspR { ErssuspR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Erase All Request"] # [inline (always)] pub fn ersareq (& self) -> ErsareqR { ErsareqR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Read Collision Error Interrupt Enable"] # [inline (always)] pub fn rdcollie (& self) -> RdcollieR { RdcollieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Command Complete Interrupt Enable"] # [inline (always)] pub fn ccie (& self) -> CcieR { CcieR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 4 - Erase Suspend"] # [inline (always)] # [must_use] pub fn erssusp (& mut self) -> ErssuspW < FcnfgSpec > { ErssuspW :: new (self , 4) } # [doc = "Bit 6 - Read Collision Error Interrupt Enable"] # [inline (always)] # [must_use] pub fn rdcollie (& mut self) -> RdcollieW < FcnfgSpec > { RdcollieW :: new (self , 6) } # [doc = "Bit 7 - Command Complete Interrupt Enable"] # [inline (always)] # [must_use] pub fn ccie (& mut self) -> CcieW < FcnfgSpec > { CcieW :: new (self , 7) } } # [doc = "Flash Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcnfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcnfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FcnfgSpec ; impl crate :: RegisterSpec for FcnfgSpec { type Ux = u8 ; } # [doc = "`read()` method returns [`fcnfg::R`](R) reader structure"] impl crate :: Readable for FcnfgSpec { } # [doc = "`write(|w| ..)` method takes [`fcnfg::W`](W) writer structure"] impl crate :: Writable for FcnfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets FCNFG to value 0"] impl crate :: Resettable for FcnfgSpec { const RESET_VALUE : u8 = 0 ; }