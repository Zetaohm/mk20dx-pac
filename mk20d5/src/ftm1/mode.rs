# [doc = "Register `MODE` reader"] pub type R = crate :: R < ModeSpec > ; # [doc = "Register `MODE` writer"] pub type W = crate :: W < ModeSpec > ; # [doc = "FTM Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ftmen { # [doc = "0: Only the TPM-compatible registers (first set of registers) can be used without any restriction. Do not use the FTM-specific registers."] _0 = 0 , # [doc = "1: All registers including the FTM-specific registers (second set of registers) are available for use with no restrictions."] _1 = 1 , } impl From < Ftmen > for bool { # [inline (always)] fn from (variant : Ftmen) -> Self { variant as u8 != 0 } } # [doc = "Field `FTMEN` reader - FTM Enable"] pub type FtmenR = crate :: BitReader < Ftmen > ; impl FtmenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ftmen { match self . bits { false => Ftmen :: _0 , true => Ftmen :: _1 , } } # [doc = "Only the TPM-compatible registers (first set of registers) can be used without any restriction. Do not use the FTM-specific registers."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ftmen :: _0 } # [doc = "All registers including the FTM-specific registers (second set of registers) are available for use with no restrictions."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ftmen :: _1 } } # [doc = "Field `FTMEN` writer - FTM Enable"] pub type FtmenW < 'a , REG > = crate :: BitWriter < 'a , REG , Ftmen > ; impl < 'a , REG > FtmenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Only the TPM-compatible registers (first set of registers) can be used without any restriction. Do not use the FTM-specific registers."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ftmen :: _0) } # [doc = "All registers including the FTM-specific registers (second set of registers) are available for use with no restrictions."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ftmen :: _1) } } # [doc = "Field `INIT` reader - Initialize the Channels Output"] pub type InitR = crate :: BitReader ; # [doc = "Field `INIT` writer - Initialize the Channels Output"] pub type InitW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Write Protection Disable\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wpdis { # [doc = "0: Write protection is enabled."] _0 = 0 , # [doc = "1: Write protection is disabled."] _1 = 1 , } impl From < Wpdis > for bool { # [inline (always)] fn from (variant : Wpdis) -> Self { variant as u8 != 0 } } # [doc = "Field `WPDIS` reader - Write Protection Disable"] pub type WpdisR = crate :: BitReader < Wpdis > ; impl WpdisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wpdis { match self . bits { false => Wpdis :: _0 , true => Wpdis :: _1 , } } # [doc = "Write protection is enabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Wpdis :: _0 } # [doc = "Write protection is disabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Wpdis :: _1 } } # [doc = "Field `WPDIS` writer - Write Protection Disable"] pub type WpdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Wpdis > ; impl < 'a , REG > WpdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Write protection is enabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Wpdis :: _0) } # [doc = "Write protection is disabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Wpdis :: _1) } } # [doc = "PWM Synchronization Mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pwmsync { # [doc = "0: No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization."] _0 = 0 , # [doc = "1: Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization."] _1 = 1 , } impl From < Pwmsync > for bool { # [inline (always)] fn from (variant : Pwmsync) -> Self { variant as u8 != 0 } } # [doc = "Field `PWMSYNC` reader - PWM Synchronization Mode"] pub type PwmsyncR = crate :: BitReader < Pwmsync > ; impl PwmsyncR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pwmsync { match self . bits { false => Pwmsync :: _0 , true => Pwmsync :: _1 , } } # [doc = "No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pwmsync :: _0 } # [doc = "Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pwmsync :: _1 } } # [doc = "Field `PWMSYNC` writer - PWM Synchronization Mode"] pub type PwmsyncW < 'a , REG > = crate :: BitWriter < 'a , REG , Pwmsync > ; impl < 'a , REG > PwmsyncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pwmsync :: _0) } # [doc = "Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pwmsync :: _1) } } # [doc = "Capture Test Mode Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Captest { # [doc = "0: Capture test mode is disabled."] _0 = 0 , # [doc = "1: Capture test mode is enabled."] _1 = 1 , } impl From < Captest > for bool { # [inline (always)] fn from (variant : Captest) -> Self { variant as u8 != 0 } } # [doc = "Field `CAPTEST` reader - Capture Test Mode Enable"] pub type CaptestR = crate :: BitReader < Captest > ; impl CaptestR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Captest { match self . bits { false => Captest :: _0 , true => Captest :: _1 , } } # [doc = "Capture test mode is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Captest :: _0 } # [doc = "Capture test mode is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Captest :: _1 } } # [doc = "Field `CAPTEST` writer - Capture Test Mode Enable"] pub type CaptestW < 'a , REG > = crate :: BitWriter < 'a , REG , Captest > ; impl < 'a , REG > CaptestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Capture test mode is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Captest :: _0) } # [doc = "Capture test mode is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Captest :: _1) } } # [doc = "Fault Control Mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Faultm { # [doc = "0: Fault control is disabled for all channels."] _00 = 0 , # [doc = "1: Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing."] _01 = 1 , # [doc = "2: Fault control is enabled for all channels, and the selected mode is the manual fault clearing."] _10 = 2 , # [doc = "3: Fault control is enabled for all channels, and the selected mode is the automatic fault clearing."] _11 = 3 , } impl From < Faultm > for u8 { # [inline (always)] fn from (variant : Faultm) -> Self { variant as _ } } impl crate :: FieldSpec for Faultm { type Ux = u8 ; } impl crate :: IsEnum for Faultm { } # [doc = "Field `FAULTM` reader - Fault Control Mode"] pub type FaultmR = crate :: FieldReader < Faultm > ; impl FaultmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Faultm { match self . bits { 0 => Faultm :: _00 , 1 => Faultm :: _01 , 2 => Faultm :: _10 , 3 => Faultm :: _11 , _ => unreachable ! () , } } # [doc = "Fault control is disabled for all channels."] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Faultm :: _00 } # [doc = "Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing."] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Faultm :: _01 } # [doc = "Fault control is enabled for all channels, and the selected mode is the manual fault clearing."] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Faultm :: _10 } # [doc = "Fault control is enabled for all channels, and the selected mode is the automatic fault clearing."] # [inline (always)] pub fn is_11 (& self) -> bool { * self == Faultm :: _11 } } # [doc = "Field `FAULTM` writer - Fault Control Mode"] pub type FaultmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Faultm , crate :: Safe > ; impl < 'a , REG > FaultmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Fault control is disabled for all channels."] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultm :: _00) } # [doc = "Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing."] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultm :: _01) } # [doc = "Fault control is enabled for all channels, and the selected mode is the manual fault clearing."] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultm :: _10) } # [doc = "Fault control is enabled for all channels, and the selected mode is the automatic fault clearing."] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultm :: _11) } } # [doc = "Fault Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Faultie { # [doc = "0: Fault control interrupt is disabled."] _0 = 0 , # [doc = "1: Fault control interrupt is enabled."] _1 = 1 , } impl From < Faultie > for bool { # [inline (always)] fn from (variant : Faultie) -> Self { variant as u8 != 0 } } # [doc = "Field `FAULTIE` reader - Fault Interrupt Enable"] pub type FaultieR = crate :: BitReader < Faultie > ; impl FaultieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Faultie { match self . bits { false => Faultie :: _0 , true => Faultie :: _1 , } } # [doc = "Fault control interrupt is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Faultie :: _0 } # [doc = "Fault control interrupt is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Faultie :: _1 } } # [doc = "Field `FAULTIE` writer - Fault Interrupt Enable"] pub type FaultieW < 'a , REG > = crate :: BitWriter < 'a , REG , Faultie > ; impl < 'a , REG > FaultieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Fault control interrupt is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultie :: _0) } # [doc = "Fault control interrupt is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Faultie :: _1) } } impl R { # [doc = "Bit 0 - FTM Enable"] # [inline (always)] pub fn ftmen (& self) -> FtmenR { FtmenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Initialize the Channels Output"] # [inline (always)] pub fn init (& self) -> InitR { InitR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Write Protection Disable"] # [inline (always)] pub fn wpdis (& self) -> WpdisR { WpdisR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - PWM Synchronization Mode"] # [inline (always)] pub fn pwmsync (& self) -> PwmsyncR { PwmsyncR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture Test Mode Enable"] # [inline (always)] pub fn captest (& self) -> CaptestR { CaptestR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Fault Control Mode"] # [inline (always)] pub fn faultm (& self) -> FaultmR { FaultmR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Fault Interrupt Enable"] # [inline (always)] pub fn faultie (& self) -> FaultieR { FaultieR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - FTM Enable"] # [inline (always)] # [must_use] pub fn ftmen (& mut self) -> FtmenW < ModeSpec > { FtmenW :: new (self , 0) } # [doc = "Bit 1 - Initialize the Channels Output"] # [inline (always)] # [must_use] pub fn init (& mut self) -> InitW < ModeSpec > { InitW :: new (self , 1) } # [doc = "Bit 2 - Write Protection Disable"] # [inline (always)] # [must_use] pub fn wpdis (& mut self) -> WpdisW < ModeSpec > { WpdisW :: new (self , 2) } # [doc = "Bit 3 - PWM Synchronization Mode"] # [inline (always)] # [must_use] pub fn pwmsync (& mut self) -> PwmsyncW < ModeSpec > { PwmsyncW :: new (self , 3) } # [doc = "Bit 4 - Capture Test Mode Enable"] # [inline (always)] # [must_use] pub fn captest (& mut self) -> CaptestW < ModeSpec > { CaptestW :: new (self , 4) } # [doc = "Bits 5:6 - Fault Control Mode"] # [inline (always)] # [must_use] pub fn faultm (& mut self) -> FaultmW < ModeSpec > { FaultmW :: new (self , 5) } # [doc = "Bit 7 - Fault Interrupt Enable"] # [inline (always)] # [must_use] pub fn faultie (& mut self) -> FaultieW < ModeSpec > { FaultieW :: new (self , 7) } } # [doc = "Features Mode Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModeSpec ; impl crate :: RegisterSpec for ModeSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mode::R`](R) reader structure"] impl crate :: Readable for ModeSpec { } # [doc = "`write(|w| ..)` method takes [`mode::W`](W) writer structure"] impl crate :: Writable for ModeSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MODE to value 0x04"] impl crate :: Resettable for ModeSpec { const RESET_VALUE : u32 = 0x04 ; }