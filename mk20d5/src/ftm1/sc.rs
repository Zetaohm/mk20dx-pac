# [doc = "Register `SC` reader"] pub type R = crate :: R < ScSpec > ; # [doc = "Register `SC` writer"] pub type W = crate :: W < ScSpec > ; # [doc = "Prescale Factor Selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ps { # [doc = "0: Divide by 1"] Div1 = 0 , # [doc = "1: Divide by 2"] Div2 = 1 , # [doc = "2: Divide by 4"] Div4 = 2 , # [doc = "3: Divide by 8"] Div8 = 3 , # [doc = "4: Divide by 16"] Div16 = 4 , # [doc = "5: Divide by 32"] Div32 = 5 , # [doc = "6: Divide by 64"] Div64 = 6 , # [doc = "7: Divide by 128"] Div128 = 7 , } impl From < Ps > for u8 { # [inline (always)] fn from (variant : Ps) -> Self { variant as _ } } impl crate :: FieldSpec for Ps { type Ux = u8 ; } impl crate :: IsEnum for Ps { } # [doc = "Field `PS` reader - Prescale Factor Selection"] pub type PsR = crate :: FieldReader < Ps > ; impl PsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ps { match self . bits { 0 => Ps :: Div1 , 1 => Ps :: Div2 , 2 => Ps :: Div4 , 3 => Ps :: Div8 , 4 => Ps :: Div16 , 5 => Ps :: Div32 , 6 => Ps :: Div64 , 7 => Ps :: Div128 , _ => unreachable ! () , } } # [doc = "Divide by 1"] # [inline (always)] pub fn is_div1 (& self) -> bool { * self == Ps :: Div1 } # [doc = "Divide by 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Ps :: Div2 } # [doc = "Divide by 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Ps :: Div4 } # [doc = "Divide by 8"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Ps :: Div8 } # [doc = "Divide by 16"] # [inline (always)] pub fn is_div16 (& self) -> bool { * self == Ps :: Div16 } # [doc = "Divide by 32"] # [inline (always)] pub fn is_div32 (& self) -> bool { * self == Ps :: Div32 } # [doc = "Divide by 64"] # [inline (always)] pub fn is_div64 (& self) -> bool { * self == Ps :: Div64 } # [doc = "Divide by 128"] # [inline (always)] pub fn is_div128 (& self) -> bool { * self == Ps :: Div128 } } # [doc = "Field `PS` writer - Prescale Factor Selection"] pub type PsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Ps , crate :: Safe > ; impl < 'a , REG > PsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divide by 1"] # [inline (always)] pub fn div1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div1) } # [doc = "Divide by 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div2) } # [doc = "Divide by 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div4) } # [doc = "Divide by 8"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div8) } # [doc = "Divide by 16"] # [inline (always)] pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div16) } # [doc = "Divide by 32"] # [inline (always)] pub fn div32 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div32) } # [doc = "Divide by 64"] # [inline (always)] pub fn div64 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div64) } # [doc = "Divide by 128"] # [inline (always)] pub fn div128 (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Div128) } } # [doc = "Clock Source Selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Clks { # [doc = "0: No clock selected (counter disabled)"] None = 0 , # [doc = "1: System clock"] System = 1 , # [doc = "2: Fixed frequency clock"] FixedFreq = 2 , # [doc = "3: External clock"] External = 3 , } impl From < Clks > for u8 { # [inline (always)] fn from (variant : Clks) -> Self { variant as _ } } impl crate :: FieldSpec for Clks { type Ux = u8 ; } impl crate :: IsEnum for Clks { } # [doc = "Field `CLKS` reader - Clock Source Selection"] pub type ClksR = crate :: FieldReader < Clks > ; impl ClksR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Clks { match self . bits { 0 => Clks :: None , 1 => Clks :: System , 2 => Clks :: FixedFreq , 3 => Clks :: External , _ => unreachable ! () , } } # [doc = "No clock selected (counter disabled)"] # [inline (always)] pub fn is_none (& self) -> bool { * self == Clks :: None } # [doc = "System clock"] # [inline (always)] pub fn is_system (& self) -> bool { * self == Clks :: System } # [doc = "Fixed frequency clock"] # [inline (always)] pub fn is_fixed_freq (& self) -> bool { * self == Clks :: FixedFreq } # [doc = "External clock"] # [inline (always)] pub fn is_external (& self) -> bool { * self == Clks :: External } } # [doc = "Field `CLKS` writer - Clock Source Selection"] pub type ClksW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Clks , crate :: Safe > ; impl < 'a , REG > ClksW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No clock selected (counter disabled)"] # [inline (always)] pub fn none (self) -> & 'a mut crate :: W < REG > { self . variant (Clks :: None) } # [doc = "System clock"] # [inline (always)] pub fn system (self) -> & 'a mut crate :: W < REG > { self . variant (Clks :: System) } # [doc = "Fixed frequency clock"] # [inline (always)] pub fn fixed_freq (self) -> & 'a mut crate :: W < REG > { self . variant (Clks :: FixedFreq) } # [doc = "External clock"] # [inline (always)] pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Clks :: External) } } # [doc = "Center-aligned PWM Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cpwms { # [doc = "0: FTM counter operates in up counting mode."] _0 = 0 , # [doc = "1: FTM counter operates in up-down counting mode."] _1 = 1 , } impl From < Cpwms > for bool { # [inline (always)] fn from (variant : Cpwms) -> Self { variant as u8 != 0 } } # [doc = "Field `CPWMS` reader - Center-aligned PWM Select"] pub type CpwmsR = crate :: BitReader < Cpwms > ; impl CpwmsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cpwms { match self . bits { false => Cpwms :: _0 , true => Cpwms :: _1 , } } # [doc = "FTM counter operates in up counting mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Cpwms :: _0 } # [doc = "FTM counter operates in up-down counting mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Cpwms :: _1 } } # [doc = "Field `CPWMS` writer - Center-aligned PWM Select"] pub type CpwmsW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpwms > ; impl < 'a , REG > CpwmsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FTM counter operates in up counting mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpwms :: _0) } # [doc = "FTM counter operates in up-down counting mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpwms :: _1) } } # [doc = "Timer Overflow Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Toie { # [doc = "0: Disable TOF interrupts. Use software polling."] _0 = 0 , # [doc = "1: Enable TOF interrupts. An interrupt is generated when TOF equals one."] _1 = 1 , } impl From < Toie > for bool { # [inline (always)] fn from (variant : Toie) -> Self { variant as u8 != 0 } } # [doc = "Field `TOIE` reader - Timer Overflow Interrupt Enable"] pub type ToieR = crate :: BitReader < Toie > ; impl ToieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Toie { match self . bits { false => Toie :: _0 , true => Toie :: _1 , } } # [doc = "Disable TOF interrupts. Use software polling."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Toie :: _0 } # [doc = "Enable TOF interrupts. An interrupt is generated when TOF equals one."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Toie :: _1 } } # [doc = "Field `TOIE` writer - Timer Overflow Interrupt Enable"] pub type ToieW < 'a , REG > = crate :: BitWriter < 'a , REG , Toie > ; impl < 'a , REG > ToieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disable TOF interrupts. Use software polling."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Toie :: _0) } # [doc = "Enable TOF interrupts. An interrupt is generated when TOF equals one."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Toie :: _1) } } # [doc = "Timer Overflow Flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tof { # [doc = "0: FTM counter has not overflowed."] _0 = 0 , # [doc = "1: FTM counter has overflowed."] _1 = 1 , } impl From < Tof > for bool { # [inline (always)] fn from (variant : Tof) -> Self { variant as u8 != 0 } } # [doc = "Field `TOF` reader - Timer Overflow Flag"] pub type TofR = crate :: BitReader < Tof > ; impl TofR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tof { match self . bits { false => Tof :: _0 , true => Tof :: _1 , } } # [doc = "FTM counter has not overflowed."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tof :: _0 } # [doc = "FTM counter has overflowed."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tof :: _1 } } impl R { # [doc = "Bits 0:2 - Prescale Factor Selection"] # [inline (always)] pub fn ps (& self) -> PsR { PsR :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:4 - Clock Source Selection"] # [inline (always)] pub fn clks (& self) -> ClksR { ClksR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bit 5 - Center-aligned PWM Select"] # [inline (always)] pub fn cpwms (& self) -> CpwmsR { CpwmsR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Timer Overflow Interrupt Enable"] # [inline (always)] pub fn toie (& self) -> ToieR { ToieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Timer Overflow Flag"] # [inline (always)] pub fn tof (& self) -> TofR { TofR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Prescale Factor Selection"] # [inline (always)] # [must_use] pub fn ps (& mut self) -> PsW < ScSpec > { PsW :: new (self , 0) } # [doc = "Bits 3:4 - Clock Source Selection"] # [inline (always)] # [must_use] pub fn clks (& mut self) -> ClksW < ScSpec > { ClksW :: new (self , 3) } # [doc = "Bit 5 - Center-aligned PWM Select"] # [inline (always)] # [must_use] pub fn cpwms (& mut self) -> CpwmsW < ScSpec > { CpwmsW :: new (self , 5) } # [doc = "Bit 6 - Timer Overflow Interrupt Enable"] # [inline (always)] # [must_use] pub fn toie (& mut self) -> ToieW < ScSpec > { ToieW :: new (self , 6) } } # [doc = "Status and Control\n\nYou can [`read`](crate::Reg::read) this register and get [`sc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ScSpec ; impl crate :: RegisterSpec for ScSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sc::R`](R) reader structure"] impl crate :: Readable for ScSpec { } # [doc = "`write(|w| ..)` method takes [`sc::W`](W) writer structure"] impl crate :: Writable for ScSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SC to value 0"] impl crate :: Resettable for ScSpec { const RESET_VALUE : u32 = 0 ; }