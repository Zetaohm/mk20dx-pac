# [doc = "Register `C1` reader"] pub type R = crate :: R < C1Spec > ; # [doc = "Register `C1` writer"] pub type W = crate :: W < C1Spec > ; # [doc = "DMA enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaen { # [doc = "0: All DMA signalling disabled."] _0 = 0 , # [doc = "1: DMA transfer is enabled and the following conditions trigger the DMA request: While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received matches the A1 register or is general call address. If any address matching occurs, IAAS and TCF are set. If the direction of transfer is known from master to slave, then it is not required to check the SRW. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted."] _1 = 1 , } impl From < Dmaen > for bool { # [inline (always)] fn from (variant : Dmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN` reader - DMA enable"] pub type DmaenR = crate :: BitReader < Dmaen > ; impl DmaenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaen { match self . bits { false => Dmaen :: _0 , true => Dmaen :: _1 , } } # [doc = "All DMA signalling disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dmaen :: _0 } # [doc = "DMA transfer is enabled and the following conditions trigger the DMA request: While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received matches the A1 register or is general call address. If any address matching occurs, IAAS and TCF are set. If the direction of transfer is known from master to slave, then it is not required to check the SRW. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dmaen :: _1 } } # [doc = "Field `DMAEN` writer - DMA enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen > ; impl < 'a , REG > DmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "All DMA signalling disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: _0) } # [doc = "DMA transfer is enabled and the following conditions trigger the DMA request: While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received matches the A1 register or is general call address. If any address matching occurs, IAAS and TCF are set. If the direction of transfer is known from master to slave, then it is not required to check the SRW. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: _1) } } # [doc = "Wakeup enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wuen { # [doc = "0: Normal operation. No interrupt generated when address matching in low power mode."] _0 = 0 , # [doc = "1: Enables the wakeup function in low power mode."] _1 = 1 , } impl From < Wuen > for bool { # [inline (always)] fn from (variant : Wuen) -> Self { variant as u8 != 0 } } # [doc = "Field `WUEN` reader - Wakeup enable"] pub type WuenR = crate :: BitReader < Wuen > ; impl WuenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wuen { match self . bits { false => Wuen :: _0 , true => Wuen :: _1 , } } # [doc = "Normal operation. No interrupt generated when address matching in low power mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Wuen :: _0 } # [doc = "Enables the wakeup function in low power mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Wuen :: _1 } } # [doc = "Field `WUEN` writer - Wakeup enable"] pub type WuenW < 'a , REG > = crate :: BitWriter < 'a , REG , Wuen > ; impl < 'a , REG > WuenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal operation. No interrupt generated when address matching in low power mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Wuen :: _0) } # [doc = "Enables the wakeup function in low power mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Wuen :: _1) } } # [doc = "Field `RSTA` writer - Repeat START"] pub type RstaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Transmit acknowledge enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txak { # [doc = "0: An acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving byte."] _0 = 0 , # [doc = "1: No acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving data byte.SCL is held low until TXAK is written."] _1 = 1 , } impl From < Txak > for bool { # [inline (always)] fn from (variant : Txak) -> Self { variant as u8 != 0 } } # [doc = "Field `TXAK` reader - Transmit acknowledge enable"] pub type TxakR = crate :: BitReader < Txak > ; impl TxakR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txak { match self . bits { false => Txak :: _0 , true => Txak :: _1 , } } # [doc = "An acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving byte."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Txak :: _0 } # [doc = "No acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving data byte.SCL is held low until TXAK is written."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Txak :: _1 } } # [doc = "Field `TXAK` writer - Transmit acknowledge enable"] pub type TxakW < 'a , REG > = crate :: BitWriter < 'a , REG , Txak > ; impl < 'a , REG > TxakW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "An acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving byte."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Txak :: _0) } # [doc = "No acknowledge signal is sent to the bus on the following (if FACK is cleared) or current (if FACK is set) receiving data byte.SCL is held low until TXAK is written."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Txak :: _1) } } # [doc = "Transmit mode select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tx { # [doc = "0: Receive"] _0 = 0 , # [doc = "1: Transmit"] _1 = 1 , } impl From < Tx > for bool { # [inline (always)] fn from (variant : Tx) -> Self { variant as u8 != 0 } } # [doc = "Field `TX` reader - Transmit mode select"] pub type TxR = crate :: BitReader < Tx > ; impl TxR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tx { match self . bits { false => Tx :: _0 , true => Tx :: _1 , } } # [doc = "Receive"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tx :: _0 } # [doc = "Transmit"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tx :: _1 } } # [doc = "Field `TX` writer - Transmit mode select"] pub type TxW < 'a , REG > = crate :: BitWriter < 'a , REG , Tx > ; impl < 'a , REG > TxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Receive"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tx :: _0) } # [doc = "Transmit"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tx :: _1) } } # [doc = "Master mode select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mst { # [doc = "0: Slave mode"] _0 = 0 , # [doc = "1: Master mode"] _1 = 1 , } impl From < Mst > for bool { # [inline (always)] fn from (variant : Mst) -> Self { variant as u8 != 0 } } # [doc = "Field `MST` reader - Master mode select"] pub type MstR = crate :: BitReader < Mst > ; impl MstR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mst { match self . bits { false => Mst :: _0 , true => Mst :: _1 , } } # [doc = "Slave mode"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Mst :: _0 } # [doc = "Master mode"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Mst :: _1 } } # [doc = "Field `MST` writer - Master mode select"] pub type MstW < 'a , REG > = crate :: BitWriter < 'a , REG , Mst > ; impl < 'a , REG > MstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Slave mode"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mst :: _0) } # [doc = "Master mode"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mst :: _1) } } # [doc = "I2C interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iicie { # [doc = "0: Disabled"] _0 = 0 , # [doc = "1: Enabled"] _1 = 1 , } impl From < Iicie > for bool { # [inline (always)] fn from (variant : Iicie) -> Self { variant as u8 != 0 } } # [doc = "Field `IICIE` reader - I2C interrupt enable"] pub type IicieR = crate :: BitReader < Iicie > ; impl IicieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iicie { match self . bits { false => Iicie :: _0 , true => Iicie :: _1 , } } # [doc = "Disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Iicie :: _0 } # [doc = "Enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Iicie :: _1 } } # [doc = "Field `IICIE` writer - I2C interrupt enable"] pub type IicieW < 'a , REG > = crate :: BitWriter < 'a , REG , Iicie > ; impl < 'a , REG > IicieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicie :: _0) } # [doc = "Enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicie :: _1) } } # [doc = "I2C enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iicen { # [doc = "0: Disabled"] _0 = 0 , # [doc = "1: Enabled"] _1 = 1 , } impl From < Iicen > for bool { # [inline (always)] fn from (variant : Iicen) -> Self { variant as u8 != 0 } } # [doc = "Field `IICEN` reader - I2C enable"] pub type IicenR = crate :: BitReader < Iicen > ; impl IicenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iicen { match self . bits { false => Iicen :: _0 , true => Iicen :: _1 , } } # [doc = "Disabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Iicen :: _0 } # [doc = "Enabled"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Iicen :: _1 } } # [doc = "Field `IICEN` writer - I2C enable"] pub type IicenW < 'a , REG > = crate :: BitWriter < 'a , REG , Iicen > ; impl < 'a , REG > IicenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicen :: _0) } # [doc = "Enabled"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicen :: _1) } } impl R { # [doc = "Bit 0 - DMA enable"] # [inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Wakeup enable"] # [inline (always)] pub fn wuen (& self) -> WuenR { WuenR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Transmit acknowledge enable"] # [inline (always)] pub fn txak (& self) -> TxakR { TxakR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transmit mode select"] # [inline (always)] pub fn tx (& self) -> TxR { TxR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Master mode select"] # [inline (always)] pub fn mst (& self) -> MstR { MstR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C interrupt enable"] # [inline (always)] pub fn iicie (& self) -> IicieR { IicieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C enable"] # [inline (always)] pub fn iicen (& self) -> IicenR { IicenR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DMA enable"] # [inline (always)] # [must_use] pub fn dmaen (& mut self) -> DmaenW < C1Spec > { DmaenW :: new (self , 0) } # [doc = "Bit 1 - Wakeup enable"] # [inline (always)] # [must_use] pub fn wuen (& mut self) -> WuenW < C1Spec > { WuenW :: new (self , 1) } # [doc = "Bit 2 - Repeat START"] # [inline (always)] # [must_use] pub fn rsta (& mut self) -> RstaW < C1Spec > { RstaW :: new (self , 2) } # [doc = "Bit 3 - Transmit acknowledge enable"] # [inline (always)] # [must_use] pub fn txak (& mut self) -> TxakW < C1Spec > { TxakW :: new (self , 3) } # [doc = "Bit 4 - Transmit mode select"] # [inline (always)] # [must_use] pub fn tx (& mut self) -> TxW < C1Spec > { TxW :: new (self , 4) } # [doc = "Bit 5 - Master mode select"] # [inline (always)] # [must_use] pub fn mst (& mut self) -> MstW < C1Spec > { MstW :: new (self , 5) } # [doc = "Bit 6 - I2C interrupt enable"] # [inline (always)] # [must_use] pub fn iicie (& mut self) -> IicieW < C1Spec > { IicieW :: new (self , 6) } # [doc = "Bit 7 - I2C enable"] # [inline (always)] # [must_use] pub fn iicen (& mut self) -> IicenW < C1Spec > { IicenW :: new (self , 7) } } # [doc = "I2C Control Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1Spec ; impl crate :: RegisterSpec for C1Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`c1::R`](R) reader structure"] impl crate :: Readable for C1Spec { } # [doc = "`write(|w| ..)` method takes [`c1::W`](W) writer structure"] impl crate :: Writable for C1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets C1 to value 0"] impl crate :: Resettable for C1Spec { const RESET_VALUE : u8 = 0 ; }