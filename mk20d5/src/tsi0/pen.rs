# [doc = "Register `PEN` reader"] pub type R = crate :: R < PenSpec > ; # [doc = "Register `PEN` writer"] pub type W = crate :: W < PenSpec > ; # [doc = "Touch Sensing Input Pin Enable Register 0\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen0 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen0 > for bool { # [inline (always)] fn from (variant : Pen0) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN0` reader - Touch Sensing Input Pin Enable Register 0"] pub type Pen0R = crate :: BitReader < Pen0 > ; impl Pen0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen0 { match self . bits { false => Pen0 :: _0 , true => Pen0 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen0 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen0 :: _1 } } # [doc = "Field `PEN0` writer - Touch Sensing Input Pin Enable Register 0"] pub type Pen0W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen0 > ; impl < 'a , REG > Pen0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen0 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen0 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen1 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen1 > for bool { # [inline (always)] fn from (variant : Pen1) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN1` reader - Touch Sensing Input Pin Enable Register 1"] pub type Pen1R = crate :: BitReader < Pen1 > ; impl Pen1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen1 { match self . bits { false => Pen1 :: _0 , true => Pen1 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen1 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen1 :: _1 } } # [doc = "Field `PEN1` writer - Touch Sensing Input Pin Enable Register 1"] pub type Pen1W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen1 > ; impl < 'a , REG > Pen1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen1 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen1 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen2 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen2 > for bool { # [inline (always)] fn from (variant : Pen2) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN2` reader - Touch Sensing Input Pin Enable Register 2"] pub type Pen2R = crate :: BitReader < Pen2 > ; impl Pen2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen2 { match self . bits { false => Pen2 :: _0 , true => Pen2 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen2 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen2 :: _1 } } # [doc = "Field `PEN2` writer - Touch Sensing Input Pin Enable Register 2"] pub type Pen2W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen2 > ; impl < 'a , REG > Pen2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen2 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen2 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen3 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen3 > for bool { # [inline (always)] fn from (variant : Pen3) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN3` reader - Touch Sensing Input Pin Enable Register 3"] pub type Pen3R = crate :: BitReader < Pen3 > ; impl Pen3R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen3 { match self . bits { false => Pen3 :: _0 , true => Pen3 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen3 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen3 :: _1 } } # [doc = "Field `PEN3` writer - Touch Sensing Input Pin Enable Register 3"] pub type Pen3W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen3 > ; impl < 'a , REG > Pen3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen3 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen3 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 4\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen4 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen4 > for bool { # [inline (always)] fn from (variant : Pen4) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN4` reader - Touch Sensing Input Pin Enable Register 4"] pub type Pen4R = crate :: BitReader < Pen4 > ; impl Pen4R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen4 { match self . bits { false => Pen4 :: _0 , true => Pen4 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen4 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen4 :: _1 } } # [doc = "Field `PEN4` writer - Touch Sensing Input Pin Enable Register 4"] pub type Pen4W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen4 > ; impl < 'a , REG > Pen4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen4 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen4 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 5\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen5 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen5 > for bool { # [inline (always)] fn from (variant : Pen5) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN5` reader - Touch Sensing Input Pin Enable Register 5"] pub type Pen5R = crate :: BitReader < Pen5 > ; impl Pen5R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen5 { match self . bits { false => Pen5 :: _0 , true => Pen5 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen5 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen5 :: _1 } } # [doc = "Field `PEN5` writer - Touch Sensing Input Pin Enable Register 5"] pub type Pen5W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen5 > ; impl < 'a , REG > Pen5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen5 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen5 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 6\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen6 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen6 > for bool { # [inline (always)] fn from (variant : Pen6) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN6` reader - Touch Sensing Input Pin Enable Register 6"] pub type Pen6R = crate :: BitReader < Pen6 > ; impl Pen6R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen6 { match self . bits { false => Pen6 :: _0 , true => Pen6 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen6 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen6 :: _1 } } # [doc = "Field `PEN6` writer - Touch Sensing Input Pin Enable Register 6"] pub type Pen6W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen6 > ; impl < 'a , REG > Pen6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen6 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen6 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 7\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen7 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen7 > for bool { # [inline (always)] fn from (variant : Pen7) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN7` reader - Touch Sensing Input Pin Enable Register 7"] pub type Pen7R = crate :: BitReader < Pen7 > ; impl Pen7R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen7 { match self . bits { false => Pen7 :: _0 , true => Pen7 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen7 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen7 :: _1 } } # [doc = "Field `PEN7` writer - Touch Sensing Input Pin Enable Register 7"] pub type Pen7W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen7 > ; impl < 'a , REG > Pen7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen7 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen7 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 8\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen8 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen8 > for bool { # [inline (always)] fn from (variant : Pen8) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN8` reader - Touch Sensing Input Pin Enable Register 8"] pub type Pen8R = crate :: BitReader < Pen8 > ; impl Pen8R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen8 { match self . bits { false => Pen8 :: _0 , true => Pen8 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen8 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen8 :: _1 } } # [doc = "Field `PEN8` writer - Touch Sensing Input Pin Enable Register 8"] pub type Pen8W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen8 > ; impl < 'a , REG > Pen8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen8 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen8 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 9\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen9 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen9 > for bool { # [inline (always)] fn from (variant : Pen9) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN9` reader - Touch Sensing Input Pin Enable Register 9"] pub type Pen9R = crate :: BitReader < Pen9 > ; impl Pen9R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen9 { match self . bits { false => Pen9 :: _0 , true => Pen9 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen9 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen9 :: _1 } } # [doc = "Field `PEN9` writer - Touch Sensing Input Pin Enable Register 9"] pub type Pen9W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen9 > ; impl < 'a , REG > Pen9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen9 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen9 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 10\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen10 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen10 > for bool { # [inline (always)] fn from (variant : Pen10) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN10` reader - Touch Sensing Input Pin Enable Register 10"] pub type Pen10R = crate :: BitReader < Pen10 > ; impl Pen10R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen10 { match self . bits { false => Pen10 :: _0 , true => Pen10 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen10 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen10 :: _1 } } # [doc = "Field `PEN10` writer - Touch Sensing Input Pin Enable Register 10"] pub type Pen10W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen10 > ; impl < 'a , REG > Pen10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen10 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen10 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 11\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen11 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen11 > for bool { # [inline (always)] fn from (variant : Pen11) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN11` reader - Touch Sensing Input Pin Enable Register 11"] pub type Pen11R = crate :: BitReader < Pen11 > ; impl Pen11R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen11 { match self . bits { false => Pen11 :: _0 , true => Pen11 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen11 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen11 :: _1 } } # [doc = "Field `PEN11` writer - Touch Sensing Input Pin Enable Register 11"] pub type Pen11W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen11 > ; impl < 'a , REG > Pen11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen11 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen11 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 12\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen12 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen12 > for bool { # [inline (always)] fn from (variant : Pen12) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN12` reader - Touch Sensing Input Pin Enable Register 12"] pub type Pen12R = crate :: BitReader < Pen12 > ; impl Pen12R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen12 { match self . bits { false => Pen12 :: _0 , true => Pen12 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen12 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen12 :: _1 } } # [doc = "Field `PEN12` writer - Touch Sensing Input Pin Enable Register 12"] pub type Pen12W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen12 > ; impl < 'a , REG > Pen12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen12 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen12 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 13\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen13 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen13 > for bool { # [inline (always)] fn from (variant : Pen13) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN13` reader - Touch Sensing Input Pin Enable Register 13"] pub type Pen13R = crate :: BitReader < Pen13 > ; impl Pen13R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen13 { match self . bits { false => Pen13 :: _0 , true => Pen13 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen13 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen13 :: _1 } } # [doc = "Field `PEN13` writer - Touch Sensing Input Pin Enable Register 13"] pub type Pen13W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen13 > ; impl < 'a , REG > Pen13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen13 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen13 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 14\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen14 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen14 > for bool { # [inline (always)] fn from (variant : Pen14) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN14` reader - Touch Sensing Input Pin Enable Register 14"] pub type Pen14R = crate :: BitReader < Pen14 > ; impl Pen14R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen14 { match self . bits { false => Pen14 :: _0 , true => Pen14 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen14 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen14 :: _1 } } # [doc = "Field `PEN14` writer - Touch Sensing Input Pin Enable Register 14"] pub type Pen14W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen14 > ; impl < 'a , REG > Pen14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen14 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen14 :: _1) } } # [doc = "Touch Sensing Input Pin Enable Register 15\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pen15 { # [doc = "0: The corresponding pin is not used by TSI."] _0 = 0 , # [doc = "1: The corresponding pin is used by TSI."] _1 = 1 , } impl From < Pen15 > for bool { # [inline (always)] fn from (variant : Pen15) -> Self { variant as u8 != 0 } } # [doc = "Field `PEN15` reader - Touch Sensing Input Pin Enable Register 15"] pub type Pen15R = crate :: BitReader < Pen15 > ; impl Pen15R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pen15 { match self . bits { false => Pen15 :: _0 , true => Pen15 :: _1 , } } # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Pen15 :: _0 } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Pen15 :: _1 } } # [doc = "Field `PEN15` writer - Touch Sensing Input Pin Enable Register 15"] pub type Pen15W < 'a , REG > = crate :: BitWriter < 'a , REG , Pen15 > ; impl < 'a , REG > Pen15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The corresponding pin is not used by TSI."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen15 :: _0) } # [doc = "The corresponding pin is used by TSI."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pen15 :: _1) } } # [doc = "Low Power Scan Pin\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Lpsp { # [doc = "0: TSI_IN\\[0\\]
is active in low power mode."] _0000 = 0 , # [doc = "1: TSI_IN\\[1\\]
is active in low power mode."] _0001 = 1 , # [doc = "2: TSI_IN\\[2\\]
is active in low power mode."] _0010 = 2 , # [doc = "3: TSI_IN\\[3\\]
is active in low power mode."] _0011 = 3 , # [doc = "4: TSI_IN\\[4\\]
is active in low power mode."] _0100 = 4 , # [doc = "5: TSI_IN\\[5\\]
is active in low power mode."] _0101 = 5 , # [doc = "6: TSI_IN\\[6\\]
is active in low power mode."] _0110 = 6 , # [doc = "7: TSI_IN\\[7\\]
is active in low power mode."] _0111 = 7 , # [doc = "8: TSI_IN\\[8\\]
is active in low power mode."] _1000 = 8 , # [doc = "9: TSI_IN\\[9\\]
is active in low power mode."] _1001 = 9 , # [doc = "10: TSI_IN\\[10\\]
is active in low power mode."] _1010 = 10 , # [doc = "11: TSI_IN\\[11\\]
is active in low power mode."] _1011 = 11 , # [doc = "12: TSI_IN\\[12\\]
is active in low power mode."] _1100 = 12 , # [doc = "13: TSI_IN\\[13\\]
is active in low power mode."] _1101 = 13 , # [doc = "14: TSI_IN\\[14\\]
is active in low power mode."] _1110 = 14 , # [doc = "15: TSI_IN\\[15\\]
is active in low power mode."] _1111 = 15 , } impl From < Lpsp > for u8 { # [inline (always)] fn from (variant : Lpsp) -> Self { variant as _ } } impl crate :: FieldSpec for Lpsp { type Ux = u8 ; } impl crate :: IsEnum for Lpsp { } # [doc = "Field `LPSP` reader - Low Power Scan Pin"] pub type LpspR = crate :: FieldReader < Lpsp > ; impl LpspR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lpsp { match self . bits { 0 => Lpsp :: _0000 , 1 => Lpsp :: _0001 , 2 => Lpsp :: _0010 , 3 => Lpsp :: _0011 , 4 => Lpsp :: _0100 , 5 => Lpsp :: _0101 , 6 => Lpsp :: _0110 , 7 => Lpsp :: _0111 , 8 => Lpsp :: _1000 , 9 => Lpsp :: _1001 , 10 => Lpsp :: _1010 , 11 => Lpsp :: _1011 , 12 => Lpsp :: _1100 , 13 => Lpsp :: _1101 , 14 => Lpsp :: _1110 , 15 => Lpsp :: _1111 , _ => unreachable ! () , } } # [doc = "TSI_IN\\[0\\]
is active in low power mode."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Lpsp :: _0000 } # [doc = "TSI_IN\\[1\\]
is active in low power mode."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Lpsp :: _0001 } # [doc = "TSI_IN\\[2\\]
is active in low power mode."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Lpsp :: _0010 } # [doc = "TSI_IN\\[3\\]
is active in low power mode."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Lpsp :: _0011 } # [doc = "TSI_IN\\[4\\]
is active in low power mode."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Lpsp :: _0100 } # [doc = "TSI_IN\\[5\\]
is active in low power mode."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Lpsp :: _0101 } # [doc = "TSI_IN\\[6\\]
is active in low power mode."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Lpsp :: _0110 } # [doc = "TSI_IN\\[7\\]
is active in low power mode."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Lpsp :: _0111 } # [doc = "TSI_IN\\[8\\]
is active in low power mode."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Lpsp :: _1000 } # [doc = "TSI_IN\\[9\\]
is active in low power mode."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Lpsp :: _1001 } # [doc = "TSI_IN\\[10\\]
is active in low power mode."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Lpsp :: _1010 } # [doc = "TSI_IN\\[11\\]
is active in low power mode."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Lpsp :: _1011 } # [doc = "TSI_IN\\[12\\]
is active in low power mode."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Lpsp :: _1100 } # [doc = "TSI_IN\\[13\\]
is active in low power mode."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Lpsp :: _1101 } # [doc = "TSI_IN\\[14\\]
is active in low power mode."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Lpsp :: _1110 } # [doc = "TSI_IN\\[15\\]
is active in low power mode."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Lpsp :: _1111 } } # [doc = "Field `LPSP` writer - Low Power Scan Pin"] pub type LpspW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Lpsp , crate :: Safe > ; impl < 'a , REG > LpspW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "TSI_IN\\[0\\]
is active in low power mode."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0000) } # [doc = "TSI_IN\\[1\\]
is active in low power mode."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0001) } # [doc = "TSI_IN\\[2\\]
is active in low power mode."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0010) } # [doc = "TSI_IN\\[3\\]
is active in low power mode."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0011) } # [doc = "TSI_IN\\[4\\]
is active in low power mode."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0100) } # [doc = "TSI_IN\\[5\\]
is active in low power mode."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0101) } # [doc = "TSI_IN\\[6\\]
is active in low power mode."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0110) } # [doc = "TSI_IN\\[7\\]
is active in low power mode."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _0111) } # [doc = "TSI_IN\\[8\\]
is active in low power mode."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1000) } # [doc = "TSI_IN\\[9\\]
is active in low power mode."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1001) } # [doc = "TSI_IN\\[10\\]
is active in low power mode."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1010) } # [doc = "TSI_IN\\[11\\]
is active in low power mode."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1011) } # [doc = "TSI_IN\\[12\\]
is active in low power mode."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1100) } # [doc = "TSI_IN\\[13\\]
is active in low power mode."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1101) } # [doc = "TSI_IN\\[14\\]
is active in low power mode."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1110) } # [doc = "TSI_IN\\[15\\]
is active in low power mode."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpsp :: _1111) } } impl R { # [doc = "Bit 0 - Touch Sensing Input Pin Enable Register 0"] # [inline (always)] pub fn pen0 (& self) -> Pen0R { Pen0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Touch Sensing Input Pin Enable Register 1"] # [inline (always)] pub fn pen1 (& self) -> Pen1R { Pen1R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Touch Sensing Input Pin Enable Register 2"] # [inline (always)] pub fn pen2 (& self) -> Pen2R { Pen2R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Touch Sensing Input Pin Enable Register 3"] # [inline (always)] pub fn pen3 (& self) -> Pen3R { Pen3R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Touch Sensing Input Pin Enable Register 4"] # [inline (always)] pub fn pen4 (& self) -> Pen4R { Pen4R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Touch Sensing Input Pin Enable Register 5"] # [inline (always)] pub fn pen5 (& self) -> Pen5R { Pen5R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Touch Sensing Input Pin Enable Register 6"] # [inline (always)] pub fn pen6 (& self) -> Pen6R { Pen6R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Touch Sensing Input Pin Enable Register 7"] # [inline (always)] pub fn pen7 (& self) -> Pen7R { Pen7R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Touch Sensing Input Pin Enable Register 8"] # [inline (always)] pub fn pen8 (& self) -> Pen8R { Pen8R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Touch Sensing Input Pin Enable Register 9"] # [inline (always)] pub fn pen9 (& self) -> Pen9R { Pen9R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Touch Sensing Input Pin Enable Register 10"] # [inline (always)] pub fn pen10 (& self) -> Pen10R { Pen10R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Touch Sensing Input Pin Enable Register 11"] # [inline (always)] pub fn pen11 (& self) -> Pen11R { Pen11R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Touch Sensing Input Pin Enable Register 12"] # [inline (always)] pub fn pen12 (& self) -> Pen12R { Pen12R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Touch Sensing Input Pin Enable Register 13"] # [inline (always)] pub fn pen13 (& self) -> Pen13R { Pen13R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Touch Sensing Input Pin Enable Register 14"] # [inline (always)] pub fn pen14 (& self) -> Pen14R { Pen14R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Touch Sensing Input Pin Enable Register 15"] # [inline (always)] pub fn pen15 (& self) -> Pen15R { Pen15R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:19 - Low Power Scan Pin"] # [inline (always)] pub fn lpsp (& self) -> LpspR { LpspR :: new (((self . bits >> 16) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Touch Sensing Input Pin Enable Register 0"] # [inline (always)] # [must_use] pub fn pen0 (& mut self) -> Pen0W < PenSpec > { Pen0W :: new (self , 0) } # [doc = "Bit 1 - Touch Sensing Input Pin Enable Register 1"] # [inline (always)] # [must_use] pub fn pen1 (& mut self) -> Pen1W < PenSpec > { Pen1W :: new (self , 1) } # [doc = "Bit 2 - Touch Sensing Input Pin Enable Register 2"] # [inline (always)] # [must_use] pub fn pen2 (& mut self) -> Pen2W < PenSpec > { Pen2W :: new (self , 2) } # [doc = "Bit 3 - Touch Sensing Input Pin Enable Register 3"] # [inline (always)] # [must_use] pub fn pen3 (& mut self) -> Pen3W < PenSpec > { Pen3W :: new (self , 3) } # [doc = "Bit 4 - Touch Sensing Input Pin Enable Register 4"] # [inline (always)] # [must_use] pub fn pen4 (& mut self) -> Pen4W < PenSpec > { Pen4W :: new (self , 4) } # [doc = "Bit 5 - Touch Sensing Input Pin Enable Register 5"] # [inline (always)] # [must_use] pub fn pen5 (& mut self) -> Pen5W < PenSpec > { Pen5W :: new (self , 5) } # [doc = "Bit 6 - Touch Sensing Input Pin Enable Register 6"] # [inline (always)] # [must_use] pub fn pen6 (& mut self) -> Pen6W < PenSpec > { Pen6W :: new (self , 6) } # [doc = "Bit 7 - Touch Sensing Input Pin Enable Register 7"] # [inline (always)] # [must_use] pub fn pen7 (& mut self) -> Pen7W < PenSpec > { Pen7W :: new (self , 7) } # [doc = "Bit 8 - Touch Sensing Input Pin Enable Register 8"] # [inline (always)] # [must_use] pub fn pen8 (& mut self) -> Pen8W < PenSpec > { Pen8W :: new (self , 8) } # [doc = "Bit 9 - Touch Sensing Input Pin Enable Register 9"] # [inline (always)] # [must_use] pub fn pen9 (& mut self) -> Pen9W < PenSpec > { Pen9W :: new (self , 9) } # [doc = "Bit 10 - Touch Sensing Input Pin Enable Register 10"] # [inline (always)] # [must_use] pub fn pen10 (& mut self) -> Pen10W < PenSpec > { Pen10W :: new (self , 10) } # [doc = "Bit 11 - Touch Sensing Input Pin Enable Register 11"] # [inline (always)] # [must_use] pub fn pen11 (& mut self) -> Pen11W < PenSpec > { Pen11W :: new (self , 11) } # [doc = "Bit 12 - Touch Sensing Input Pin Enable Register 12"] # [inline (always)] # [must_use] pub fn pen12 (& mut self) -> Pen12W < PenSpec > { Pen12W :: new (self , 12) } # [doc = "Bit 13 - Touch Sensing Input Pin Enable Register 13"] # [inline (always)] # [must_use] pub fn pen13 (& mut self) -> Pen13W < PenSpec > { Pen13W :: new (self , 13) } # [doc = "Bit 14 - Touch Sensing Input Pin Enable Register 14"] # [inline (always)] # [must_use] pub fn pen14 (& mut self) -> Pen14W < PenSpec > { Pen14W :: new (self , 14) } # [doc = "Bit 15 - Touch Sensing Input Pin Enable Register 15"] # [inline (always)] # [must_use] pub fn pen15 (& mut self) -> Pen15W < PenSpec > { Pen15W :: new (self , 15) } # [doc = "Bits 16:19 - Low Power Scan Pin"] # [inline (always)] # [must_use] pub fn lpsp (& mut self) -> LpspW < PenSpec > { LpspW :: new (self , 16) } } # [doc = "Pin Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PenSpec ; impl crate :: RegisterSpec for PenSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pen::R`](R) reader structure"] impl crate :: Readable for PenSpec { } # [doc = "`write(|w| ..)` method takes [`pen::W`](W) writer structure"] impl crate :: Writable for PenSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PEN to value 0"] impl crate :: Resettable for PenSpec { const RESET_VALUE : u32 = 0 ; }