# [doc = "Register `SCANC` reader"] pub type R = crate :: R < ScancSpec > ; # [doc = "Register `SCANC` writer"] pub type W = crate :: W < ScancSpec > ; # [doc = "Active Mode Prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ampsc { # [doc = "0: Input Clock Source divided by 1."] _000 = 0 , # [doc = "1: Input Clock Source divided by 2."] _001 = 1 , # [doc = "2: Input Clock Source divided by 4."] _010 = 2 , # [doc = "3: Input Clock Source divided by 8."] _011 = 3 , # [doc = "4: Input Clock Source divided by 16."] _100 = 4 , # [doc = "5: Input Clock Source divided by 32."] _101 = 5 , # [doc = "6: Input Clock Source divided by 64."] _110 = 6 , # [doc = "7: Input Clock Source divided by 128."] _111 = 7 , } impl From < Ampsc > for u8 { # [inline (always)] fn from (variant : Ampsc) -> Self { variant as _ } } impl crate :: FieldSpec for Ampsc { type Ux = u8 ; } impl crate :: IsEnum for Ampsc { } # [doc = "Field `AMPSC` reader - Active Mode Prescaler"] pub type AmpscR = crate :: FieldReader < Ampsc > ; impl AmpscR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ampsc { match self . bits { 0 => Ampsc :: _000 , 1 => Ampsc :: _001 , 2 => Ampsc :: _010 , 3 => Ampsc :: _011 , 4 => Ampsc :: _100 , 5 => Ampsc :: _101 , 6 => Ampsc :: _110 , 7 => Ampsc :: _111 , _ => unreachable ! () , } } # [doc = "Input Clock Source divided by 1."] # [inline (always)] pub fn is_000 (& self) -> bool { * self == Ampsc :: _000 } # [doc = "Input Clock Source divided by 2."] # [inline (always)] pub fn is_001 (& self) -> bool { * self == Ampsc :: _001 } # [doc = "Input Clock Source divided by 4."] # [inline (always)] pub fn is_010 (& self) -> bool { * self == Ampsc :: _010 } # [doc = "Input Clock Source divided by 8."] # [inline (always)] pub fn is_011 (& self) -> bool { * self == Ampsc :: _011 } # [doc = "Input Clock Source divided by 16."] # [inline (always)] pub fn is_100 (& self) -> bool { * self == Ampsc :: _100 } # [doc = "Input Clock Source divided by 32."] # [inline (always)] pub fn is_101 (& self) -> bool { * self == Ampsc :: _101 } # [doc = "Input Clock Source divided by 64."] # [inline (always)] pub fn is_110 (& self) -> bool { * self == Ampsc :: _110 } # [doc = "Input Clock Source divided by 128."] # [inline (always)] pub fn is_111 (& self) -> bool { * self == Ampsc :: _111 } } # [doc = "Field `AMPSC` writer - Active Mode Prescaler"] pub type AmpscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Ampsc , crate :: Safe > ; impl < 'a , REG > AmpscW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Input Clock Source divided by 1."] # [inline (always)] pub fn _000 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _000) } # [doc = "Input Clock Source divided by 2."] # [inline (always)] pub fn _001 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _001) } # [doc = "Input Clock Source divided by 4."] # [inline (always)] pub fn _010 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _010) } # [doc = "Input Clock Source divided by 8."] # [inline (always)] pub fn _011 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _011) } # [doc = "Input Clock Source divided by 16."] # [inline (always)] pub fn _100 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _100) } # [doc = "Input Clock Source divided by 32."] # [inline (always)] pub fn _101 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _101) } # [doc = "Input Clock Source divided by 64."] # [inline (always)] pub fn _110 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _110) } # [doc = "Input Clock Source divided by 128."] # [inline (always)] pub fn _111 (self) -> & 'a mut crate :: W < REG > { self . variant (Ampsc :: _111) } } # [doc = "Active Mode Clock Source\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Amclks { # [doc = "0: LPOSCCLK"] _00 = 0 , # [doc = "1: MCGIRCLK."] _01 = 1 , # [doc = "2: OSCERCLK."] _10 = 2 , # [doc = "3: Not valid."] _11 = 3 , } impl From < Amclks > for u8 { # [inline (always)] fn from (variant : Amclks) -> Self { variant as _ } } impl crate :: FieldSpec for Amclks { type Ux = u8 ; } impl crate :: IsEnum for Amclks { } # [doc = "Field `AMCLKS` reader - Active Mode Clock Source"] pub type AmclksR = crate :: FieldReader < Amclks > ; impl AmclksR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Amclks { match self . bits { 0 => Amclks :: _00 , 1 => Amclks :: _01 , 2 => Amclks :: _10 , 3 => Amclks :: _11 , _ => unreachable ! () , } } # [doc = "LPOSCCLK"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Amclks :: _00 } # [doc = "MCGIRCLK."] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Amclks :: _01 } # [doc = "OSCERCLK."] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Amclks :: _10 } # [doc = "Not valid."] # [inline (always)] pub fn is_11 (& self) -> bool { * self == Amclks :: _11 } } # [doc = "Field `AMCLKS` writer - Active Mode Clock Source"] pub type AmclksW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Amclks , crate :: Safe > ; impl < 'a , REG > AmclksW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "LPOSCCLK"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Amclks :: _00) } # [doc = "MCGIRCLK."] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Amclks :: _01) } # [doc = "OSCERCLK."] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Amclks :: _10) } # [doc = "Not valid."] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Amclks :: _11) } } # [doc = "Scan Module\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Smod { # [doc = "0: Continue Scan."] _00000000 = 0 , } impl From < Smod > for u8 { # [inline (always)] fn from (variant : Smod) -> Self { variant as _ } } impl crate :: FieldSpec for Smod { type Ux = u8 ; } impl crate :: IsEnum for Smod { } # [doc = "Field `SMOD` reader - Scan Module"] pub type SmodR = crate :: FieldReader < Smod > ; impl SmodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Smod > { match self . bits { 0 => Some (Smod :: _00000000) , _ => None , } } # [doc = "Continue Scan."] # [inline (always)] pub fn is_00000000 (& self) -> bool { * self == Smod :: _00000000 } } # [doc = "Field `SMOD` writer - Scan Module"] pub type SmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 , Smod > ; impl < 'a , REG > SmodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Continue Scan."] # [inline (always)] pub fn _00000000 (self) -> & 'a mut crate :: W < REG > { self . variant (Smod :: _00000000) } } # [doc = "External OSC Charge Current select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Extchrg { # [doc = "0: 2 uA charge current."] _0000 = 0 , # [doc = "1: 4 uA charge current."] _0001 = 1 , # [doc = "2: 6 uA charge current."] _0010 = 2 , # [doc = "3: 8 uA charge current."] _0011 = 3 , # [doc = "4: 10 uA charge current."] _0100 = 4 , # [doc = "5: 12 uA charge current."] _0101 = 5 , # [doc = "6: 14 uA charge current."] _0110 = 6 , # [doc = "7: 16 uA charge current."] _0111 = 7 , # [doc = "8: 18 uA charge current."] _1000 = 8 , # [doc = "9: 20 uA charge current."] _1001 = 9 , # [doc = "10: 22 uA charge current."] _1010 = 10 , # [doc = "11: 24 uA charge current."] _1011 = 11 , # [doc = "12: 26 uA charge current."] _1100 = 12 , # [doc = "13: 28 uA charge current."] _1101 = 13 , # [doc = "14: 30 uA charge current."] _1110 = 14 , # [doc = "15: 32 uA charge current."] _1111 = 15 , } impl From < Extchrg > for u8 { # [inline (always)] fn from (variant : Extchrg) -> Self { variant as _ } } impl crate :: FieldSpec for Extchrg { type Ux = u8 ; } impl crate :: IsEnum for Extchrg { } # [doc = "Field `EXTCHRG` reader - External OSC Charge Current select"] pub type ExtchrgR = crate :: FieldReader < Extchrg > ; impl ExtchrgR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Extchrg { match self . bits { 0 => Extchrg :: _0000 , 1 => Extchrg :: _0001 , 2 => Extchrg :: _0010 , 3 => Extchrg :: _0011 , 4 => Extchrg :: _0100 , 5 => Extchrg :: _0101 , 6 => Extchrg :: _0110 , 7 => Extchrg :: _0111 , 8 => Extchrg :: _1000 , 9 => Extchrg :: _1001 , 10 => Extchrg :: _1010 , 11 => Extchrg :: _1011 , 12 => Extchrg :: _1100 , 13 => Extchrg :: _1101 , 14 => Extchrg :: _1110 , 15 => Extchrg :: _1111 , _ => unreachable ! () , } } # [doc = "2 uA charge current."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Extchrg :: _0000 } # [doc = "4 uA charge current."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Extchrg :: _0001 } # [doc = "6 uA charge current."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Extchrg :: _0010 } # [doc = "8 uA charge current."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Extchrg :: _0011 } # [doc = "10 uA charge current."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Extchrg :: _0100 } # [doc = "12 uA charge current."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Extchrg :: _0101 } # [doc = "14 uA charge current."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Extchrg :: _0110 } # [doc = "16 uA charge current."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Extchrg :: _0111 } # [doc = "18 uA charge current."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Extchrg :: _1000 } # [doc = "20 uA charge current."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Extchrg :: _1001 } # [doc = "22 uA charge current."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Extchrg :: _1010 } # [doc = "24 uA charge current."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Extchrg :: _1011 } # [doc = "26 uA charge current."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Extchrg :: _1100 } # [doc = "28 uA charge current."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Extchrg :: _1101 } # [doc = "30 uA charge current."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Extchrg :: _1110 } # [doc = "32 uA charge current."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Extchrg :: _1111 } } # [doc = "Field `EXTCHRG` writer - External OSC Charge Current select"] pub type ExtchrgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Extchrg , crate :: Safe > ; impl < 'a , REG > ExtchrgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "2 uA charge current."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0000) } # [doc = "4 uA charge current."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0001) } # [doc = "6 uA charge current."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0010) } # [doc = "8 uA charge current."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0011) } # [doc = "10 uA charge current."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0100) } # [doc = "12 uA charge current."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0101) } # [doc = "14 uA charge current."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0110) } # [doc = "16 uA charge current."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _0111) } # [doc = "18 uA charge current."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1000) } # [doc = "20 uA charge current."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1001) } # [doc = "22 uA charge current."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1010) } # [doc = "24 uA charge current."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1011) } # [doc = "26 uA charge current."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1100) } # [doc = "28 uA charge current."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1101) } # [doc = "30 uA charge current."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1110) } # [doc = "32 uA charge current."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Extchrg :: _1111) } } # [doc = "Ref OSC Charge Current select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Refchrg { # [doc = "0: 2 uA charge current."] _0000 = 0 , # [doc = "1: 4 uA charge current."] _0001 = 1 , # [doc = "2: 6 uA charge current."] _0010 = 2 , # [doc = "3: 8 uA charge current."] _0011 = 3 , # [doc = "4: 10 uA charge current."] _0100 = 4 , # [doc = "5: 12 uA charge current."] _0101 = 5 , # [doc = "6: 14 uA charge current."] _0110 = 6 , # [doc = "7: 16 uA charge current."] _0111 = 7 , # [doc = "8: 18 uA charge current."] _1000 = 8 , # [doc = "9: 20 uA charge current."] _1001 = 9 , # [doc = "10: 22 uA charge current."] _1010 = 10 , # [doc = "11: 24 uA charge current."] _1011 = 11 , # [doc = "12: 26 uA charge current."] _1100 = 12 , # [doc = "13: 28 uA charge current."] _1101 = 13 , # [doc = "14: 30 uA charge current."] _1110 = 14 , # [doc = "15: 32 uA charge current."] _1111 = 15 , } impl From < Refchrg > for u8 { # [inline (always)] fn from (variant : Refchrg) -> Self { variant as _ } } impl crate :: FieldSpec for Refchrg { type Ux = u8 ; } impl crate :: IsEnum for Refchrg { } # [doc = "Field `REFCHRG` reader - Ref OSC Charge Current select"] pub type RefchrgR = crate :: FieldReader < Refchrg > ; impl RefchrgR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Refchrg { match self . bits { 0 => Refchrg :: _0000 , 1 => Refchrg :: _0001 , 2 => Refchrg :: _0010 , 3 => Refchrg :: _0011 , 4 => Refchrg :: _0100 , 5 => Refchrg :: _0101 , 6 => Refchrg :: _0110 , 7 => Refchrg :: _0111 , 8 => Refchrg :: _1000 , 9 => Refchrg :: _1001 , 10 => Refchrg :: _1010 , 11 => Refchrg :: _1011 , 12 => Refchrg :: _1100 , 13 => Refchrg :: _1101 , 14 => Refchrg :: _1110 , 15 => Refchrg :: _1111 , _ => unreachable ! () , } } # [doc = "2 uA charge current."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Refchrg :: _0000 } # [doc = "4 uA charge current."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Refchrg :: _0001 } # [doc = "6 uA charge current."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Refchrg :: _0010 } # [doc = "8 uA charge current."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Refchrg :: _0011 } # [doc = "10 uA charge current."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Refchrg :: _0100 } # [doc = "12 uA charge current."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Refchrg :: _0101 } # [doc = "14 uA charge current."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Refchrg :: _0110 } # [doc = "16 uA charge current."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Refchrg :: _0111 } # [doc = "18 uA charge current."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Refchrg :: _1000 } # [doc = "20 uA charge current."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Refchrg :: _1001 } # [doc = "22 uA charge current."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Refchrg :: _1010 } # [doc = "24 uA charge current."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Refchrg :: _1011 } # [doc = "26 uA charge current."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Refchrg :: _1100 } # [doc = "28 uA charge current."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Refchrg :: _1101 } # [doc = "30 uA charge current."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Refchrg :: _1110 } # [doc = "32 uA charge current."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Refchrg :: _1111 } } # [doc = "Field `REFCHRG` writer - Ref OSC Charge Current select"] pub type RefchrgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Refchrg , crate :: Safe > ; impl < 'a , REG > RefchrgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "2 uA charge current."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0000) } # [doc = "4 uA charge current."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0001) } # [doc = "6 uA charge current."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0010) } # [doc = "8 uA charge current."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0011) } # [doc = "10 uA charge current."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0100) } # [doc = "12 uA charge current."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0101) } # [doc = "14 uA charge current."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0110) } # [doc = "16 uA charge current."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _0111) } # [doc = "18 uA charge current."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1000) } # [doc = "20 uA charge current."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1001) } # [doc = "22 uA charge current."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1010) } # [doc = "24 uA charge current."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1011) } # [doc = "26 uA charge current."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1100) } # [doc = "28 uA charge current."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1101) } # [doc = "30 uA charge current."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1110) } # [doc = "32 uA charge current."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Refchrg :: _1111) } } impl R { # [doc = "Bits 0:2 - Active Mode Prescaler"] # [inline (always)] pub fn ampsc (& self) -> AmpscR { AmpscR :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:4 - Active Mode Clock Source"] # [inline (always)] pub fn amclks (& self) -> AmclksR { AmclksR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 8:15 - Scan Module"] # [inline (always)] pub fn smod (& self) -> SmodR { SmodR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:19 - External OSC Charge Current select"] # [inline (always)] pub fn extchrg (& self) -> ExtchrgR { ExtchrgR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 24:27 - Ref OSC Charge Current select"] # [inline (always)] pub fn refchrg (& self) -> RefchrgR { RefchrgR :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:2 - Active Mode Prescaler"] # [inline (always)] # [must_use] pub fn ampsc (& mut self) -> AmpscW < ScancSpec > { AmpscW :: new (self , 0) } # [doc = "Bits 3:4 - Active Mode Clock Source"] # [inline (always)] # [must_use] pub fn amclks (& mut self) -> AmclksW < ScancSpec > { AmclksW :: new (self , 3) } # [doc = "Bits 8:15 - Scan Module"] # [inline (always)] # [must_use] pub fn smod (& mut self) -> SmodW < ScancSpec > { SmodW :: new (self , 8) } # [doc = "Bits 16:19 - External OSC Charge Current select"] # [inline (always)] # [must_use] pub fn extchrg (& mut self) -> ExtchrgW < ScancSpec > { ExtchrgW :: new (self , 16) } # [doc = "Bits 24:27 - Ref OSC Charge Current select"] # [inline (always)] # [must_use] pub fn refchrg (& mut self) -> RefchrgW < ScancSpec > { RefchrgW :: new (self , 24) } } # [doc = "SCAN Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`scanc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scanc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ScancSpec ; impl crate :: RegisterSpec for ScancSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`scanc::R`](R) reader structure"] impl crate :: Readable for ScancSpec { } # [doc = "`write(|w| ..)` method takes [`scanc::W`](W) writer structure"] impl crate :: Writable for ScancSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SCANC to value 0"] impl crate :: Resettable for ScancSpec { const RESET_VALUE : u32 = 0 ; }