# [doc = "Register `C0` reader"] pub type R = crate :: R < C0Spec > ; # [doc = "Register `C0` writer"] pub type W = crate :: W < C0Spec > ; # [doc = "DAC buffer read pointer bottom flag interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacbbien { # [doc = "0: The DAC buffer read pointer bottom flag interrupt is disabled."] _0 = 0 , # [doc = "1: The DAC buffer read pointer bottom flag interrupt is enabled."] _1 = 1 , } impl From < Dacbbien > for bool { # [inline (always)] fn from (variant : Dacbbien) -> Self { variant as u8 != 0 } } # [doc = "Field `DACBBIEN` reader - DAC buffer read pointer bottom flag interrupt enable"] pub type DacbbienR = crate :: BitReader < Dacbbien > ; impl DacbbienR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacbbien { match self . bits { false => Dacbbien :: _0 , true => Dacbbien :: _1 , } } # [doc = "The DAC buffer read pointer bottom flag interrupt is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacbbien :: _0 } # [doc = "The DAC buffer read pointer bottom flag interrupt is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacbbien :: _1 } } # [doc = "Field `DACBBIEN` writer - DAC buffer read pointer bottom flag interrupt enable"] pub type DacbbienW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacbbien > ; impl < 'a , REG > DacbbienW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC buffer read pointer bottom flag interrupt is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbbien :: _0) } # [doc = "The DAC buffer read pointer bottom flag interrupt is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbbien :: _1) } } # [doc = "DAC buffer read pointer top flag interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacbtien { # [doc = "0: The DAC buffer read pointer top flag interrupt is disabled."] _0 = 0 , # [doc = "1: The DAC buffer read pointer top flag interrupt is enabled."] _1 = 1 , } impl From < Dacbtien > for bool { # [inline (always)] fn from (variant : Dacbtien) -> Self { variant as u8 != 0 } } # [doc = "Field `DACBTIEN` reader - DAC buffer read pointer top flag interrupt enable"] pub type DacbtienR = crate :: BitReader < Dacbtien > ; impl DacbtienR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacbtien { match self . bits { false => Dacbtien :: _0 , true => Dacbtien :: _1 , } } # [doc = "The DAC buffer read pointer top flag interrupt is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacbtien :: _0 } # [doc = "The DAC buffer read pointer top flag interrupt is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacbtien :: _1 } } # [doc = "Field `DACBTIEN` writer - DAC buffer read pointer top flag interrupt enable"] pub type DacbtienW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacbtien > ; impl < 'a , REG > DacbtienW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC buffer read pointer top flag interrupt is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbtien :: _0) } # [doc = "The DAC buffer read pointer top flag interrupt is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbtien :: _1) } } # [doc = "DAC buffer watermark interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacbwien { # [doc = "0: The DAC buffer watermark interrupt is disabled."] _0 = 0 , # [doc = "1: The DAC buffer watermark interrupt is enabled."] _1 = 1 , } impl From < Dacbwien > for bool { # [inline (always)] fn from (variant : Dacbwien) -> Self { variant as u8 != 0 } } # [doc = "Field `DACBWIEN` reader - DAC buffer watermark interrupt enable"] pub type DacbwienR = crate :: BitReader < Dacbwien > ; impl DacbwienR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacbwien { match self . bits { false => Dacbwien :: _0 , true => Dacbwien :: _1 , } } # [doc = "The DAC buffer watermark interrupt is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacbwien :: _0 } # [doc = "The DAC buffer watermark interrupt is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacbwien :: _1 } } # [doc = "Field `DACBWIEN` writer - DAC buffer watermark interrupt enable"] pub type DacbwienW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacbwien > ; impl < 'a , REG > DacbwienW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC buffer watermark interrupt is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbwien :: _0) } # [doc = "The DAC buffer watermark interrupt is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbwien :: _1) } } # [doc = "DAC low power control\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lpen { # [doc = "0: high power mode."] _0 = 0 , # [doc = "1: low power mode."] _1 = 1 , } impl From < Lpen > for bool { # [inline (always)] fn from (variant : Lpen) -> Self { variant as u8 != 0 } } # [doc = "Field `LPEN` reader - DAC low power control"] pub type LpenR = crate :: BitReader < Lpen > ; impl LpenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lpen { match self . bits { false => Lpen :: _0 , true => Lpen :: _1 , } } # [doc = "high power mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Lpen :: _0 } # [doc = "low power mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Lpen :: _1 } } # [doc = "Field `LPEN` writer - DAC low power control"] pub type LpenW < 'a , REG > = crate :: BitWriter < 'a , REG , Lpen > ; impl < 'a , REG > LpenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "high power mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpen :: _0) } # [doc = "low power mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lpen :: _1) } } # [doc = "DAC software trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacswtrg { # [doc = "0: The DAC soft trigger is not valid."] _0 = 0 , # [doc = "1: The DAC soft trigger is valid."] _1 = 1 , } impl From < Dacswtrg > for bool { # [inline (always)] fn from (variant : Dacswtrg) -> Self { variant as u8 != 0 } } # [doc = "Field `DACSWTRG` writer - DAC software trigger"] pub type DacswtrgW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacswtrg > ; impl < 'a , REG > DacswtrgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC soft trigger is not valid."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacswtrg :: _0) } # [doc = "The DAC soft trigger is valid."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacswtrg :: _1) } } # [doc = "DAC trigger select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dactrgsel { # [doc = "0: The DAC hardware trigger is selected."] _0 = 0 , # [doc = "1: The DAC software trigger is selected."] _1 = 1 , } impl From < Dactrgsel > for bool { # [inline (always)] fn from (variant : Dactrgsel) -> Self { variant as u8 != 0 } } # [doc = "Field `DACTRGSEL` reader - DAC trigger select"] pub type DactrgselR = crate :: BitReader < Dactrgsel > ; impl DactrgselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dactrgsel { match self . bits { false => Dactrgsel :: _0 , true => Dactrgsel :: _1 , } } # [doc = "The DAC hardware trigger is selected."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dactrgsel :: _0 } # [doc = "The DAC software trigger is selected."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dactrgsel :: _1 } } # [doc = "Field `DACTRGSEL` writer - DAC trigger select"] pub type DactrgselW < 'a , REG > = crate :: BitWriter < 'a , REG , Dactrgsel > ; impl < 'a , REG > DactrgselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC hardware trigger is selected."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dactrgsel :: _0) } # [doc = "The DAC software trigger is selected."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dactrgsel :: _1) } } # [doc = "DAC Reference Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacrfs { # [doc = "0: The DAC selets DACREF_1 as the reference voltage."] _0 = 0 , # [doc = "1: The DAC selets DACREF_2 as the reference voltage."] _1 = 1 , } impl From < Dacrfs > for bool { # [inline (always)] fn from (variant : Dacrfs) -> Self { variant as u8 != 0 } } # [doc = "Field `DACRFS` reader - DAC Reference Select"] pub type DacrfsR = crate :: BitReader < Dacrfs > ; impl DacrfsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacrfs { match self . bits { false => Dacrfs :: _0 , true => Dacrfs :: _1 , } } # [doc = "The DAC selets DACREF_1 as the reference voltage."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacrfs :: _0 } # [doc = "The DAC selets DACREF_2 as the reference voltage."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacrfs :: _1 } } # [doc = "Field `DACRFS` writer - DAC Reference Select"] pub type DacrfsW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacrfs > ; impl < 'a , REG > DacrfsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC selets DACREF_1 as the reference voltage."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacrfs :: _0) } # [doc = "The DAC selets DACREF_2 as the reference voltage."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacrfs :: _1) } } # [doc = "DAC enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacen { # [doc = "0: The DAC system is disabled."] _0 = 0 , # [doc = "1: The DAC system is enabled."] _1 = 1 , } impl From < Dacen > for bool { # [inline (always)] fn from (variant : Dacen) -> Self { variant as u8 != 0 } } # [doc = "Field `DACEN` reader - DAC enable"] pub type DacenR = crate :: BitReader < Dacen > ; impl DacenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacen { match self . bits { false => Dacen :: _0 , true => Dacen :: _1 , } } # [doc = "The DAC system is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacen :: _0 } # [doc = "The DAC system is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacen :: _1 } } # [doc = "Field `DACEN` writer - DAC enable"] pub type DacenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacen > ; impl < 'a , REG > DacenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DAC system is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacen :: _0) } # [doc = "The DAC system is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacen :: _1) } } impl R { # [doc = "Bit 0 - DAC buffer read pointer bottom flag interrupt enable"] # [inline (always)] pub fn dacbbien (& self) -> DacbbienR { DacbbienR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DAC buffer read pointer top flag interrupt enable"] # [inline (always)] pub fn dacbtien (& self) -> DacbtienR { DacbtienR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DAC buffer watermark interrupt enable"] # [inline (always)] pub fn dacbwien (& self) -> DacbwienR { DacbwienR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DAC low power control"] # [inline (always)] pub fn lpen (& self) -> LpenR { LpenR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - DAC trigger select"] # [inline (always)] pub fn dactrgsel (& self) -> DactrgselR { DactrgselR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DAC Reference Select"] # [inline (always)] pub fn dacrfs (& self) -> DacrfsR { DacrfsR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DAC enable"] # [inline (always)] pub fn dacen (& self) -> DacenR { DacenR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DAC buffer read pointer bottom flag interrupt enable"] # [inline (always)] # [must_use] pub fn dacbbien (& mut self) -> DacbbienW < C0Spec > { DacbbienW :: new (self , 0) } # [doc = "Bit 1 - DAC buffer read pointer top flag interrupt enable"] # [inline (always)] # [must_use] pub fn dacbtien (& mut self) -> DacbtienW < C0Spec > { DacbtienW :: new (self , 1) } # [doc = "Bit 2 - DAC buffer watermark interrupt enable"] # [inline (always)] # [must_use] pub fn dacbwien (& mut self) -> DacbwienW < C0Spec > { DacbwienW :: new (self , 2) } # [doc = "Bit 3 - DAC low power control"] # [inline (always)] # [must_use] pub fn lpen (& mut self) -> LpenW < C0Spec > { LpenW :: new (self , 3) } # [doc = "Bit 4 - DAC software trigger"] # [inline (always)] # [must_use] pub fn dacswtrg (& mut self) -> DacswtrgW < C0Spec > { DacswtrgW :: new (self , 4) } # [doc = "Bit 5 - DAC trigger select"] # [inline (always)] # [must_use] pub fn dactrgsel (& mut self) -> DactrgselW < C0Spec > { DactrgselW :: new (self , 5) } # [doc = "Bit 6 - DAC Reference Select"] # [inline (always)] # [must_use] pub fn dacrfs (& mut self) -> DacrfsW < C0Spec > { DacrfsW :: new (self , 6) } # [doc = "Bit 7 - DAC enable"] # [inline (always)] # [must_use] pub fn dacen (& mut self) -> DacenW < C0Spec > { DacenW :: new (self , 7) } } # [doc = "DAC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`c0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C0Spec ; impl crate :: RegisterSpec for C0Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`c0::R`](R) reader structure"] impl crate :: Readable for C0Spec { } # [doc = "`write(|w| ..)` method takes [`c0::W`](W) writer structure"] impl crate :: Writable for C0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets C0 to value 0"] impl crate :: Resettable for C0Spec { const RESET_VALUE : u8 = 0 ; }