# [doc = "Register `C1` reader"] pub type R = crate :: R < C1Spec > ; # [doc = "Register `C1` writer"] pub type W = crate :: W < C1Spec > ; # [doc = "DAC buffer enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dacbfen { # [doc = "0: Buffer read pointer disabled. The converted data is always the first word of the buffer."] _0 = 0 , # [doc = "1: Buffer read pointer enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."] _1 = 1 , } impl From < Dacbfen > for bool { # [inline (always)] fn from (variant : Dacbfen) -> Self { variant as u8 != 0 } } # [doc = "Field `DACBFEN` reader - DAC buffer enable"] pub type DacbfenR = crate :: BitReader < Dacbfen > ; impl DacbfenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacbfen { match self . bits { false => Dacbfen :: _0 , true => Dacbfen :: _1 , } } # [doc = "Buffer read pointer disabled. The converted data is always the first word of the buffer."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dacbfen :: _0 } # [doc = "Buffer read pointer enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dacbfen :: _1 } } # [doc = "Field `DACBFEN` writer - DAC buffer enable"] pub type DacbfenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dacbfen > ; impl < 'a , REG > DacbfenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Buffer read pointer disabled. The converted data is always the first word of the buffer."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfen :: _0) } # [doc = "Buffer read pointer enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfen :: _1) } } # [doc = "DAC buffer work mode select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Dacbfmd { # [doc = "0: Normal Mode"] _00 = 0 , # [doc = "1: Swing Mode"] _01 = 1 , # [doc = "2: One-Time Scan Mode"] _10 = 2 , } impl From < Dacbfmd > for u8 { # [inline (always)] fn from (variant : Dacbfmd) -> Self { variant as _ } } impl crate :: FieldSpec for Dacbfmd { type Ux = u8 ; } impl crate :: IsEnum for Dacbfmd { } # [doc = "Field `DACBFMD` reader - DAC buffer work mode select"] pub type DacbfmdR = crate :: FieldReader < Dacbfmd > ; impl DacbfmdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Dacbfmd > { match self . bits { 0 => Some (Dacbfmd :: _00) , 1 => Some (Dacbfmd :: _01) , 2 => Some (Dacbfmd :: _10) , _ => None , } } # [doc = "Normal Mode"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Dacbfmd :: _00 } # [doc = "Swing Mode"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Dacbfmd :: _01 } # [doc = "One-Time Scan Mode"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Dacbfmd :: _10 } } # [doc = "Field `DACBFMD` writer - DAC buffer work mode select"] pub type DacbfmdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Dacbfmd > ; impl < 'a , REG > DacbfmdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Normal Mode"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfmd :: _00) } # [doc = "Swing Mode"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfmd :: _01) } # [doc = "One-Time Scan Mode"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfmd :: _10) } } # [doc = "DAC buffer watermark select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Dacbfwm { # [doc = "0: 1 word"] _00 = 0 , # [doc = "1: 2 words"] _01 = 1 , # [doc = "2: 3 words"] _10 = 2 , # [doc = "3: 4 words"] _11 = 3 , } impl From < Dacbfwm > for u8 { # [inline (always)] fn from (variant : Dacbfwm) -> Self { variant as _ } } impl crate :: FieldSpec for Dacbfwm { type Ux = u8 ; } impl crate :: IsEnum for Dacbfwm { } # [doc = "Field `DACBFWM` reader - DAC buffer watermark select"] pub type DacbfwmR = crate :: FieldReader < Dacbfwm > ; impl DacbfwmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dacbfwm { match self . bits { 0 => Dacbfwm :: _00 , 1 => Dacbfwm :: _01 , 2 => Dacbfwm :: _10 , 3 => Dacbfwm :: _11 , _ => unreachable ! () , } } # [doc = "1 word"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Dacbfwm :: _00 } # [doc = "2 words"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Dacbfwm :: _01 } # [doc = "3 words"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Dacbfwm :: _10 } # [doc = "4 words"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == Dacbfwm :: _11 } } # [doc = "Field `DACBFWM` writer - DAC buffer watermark select"] pub type DacbfwmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Dacbfwm , crate :: Safe > ; impl < 'a , REG > DacbfwmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "1 word"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfwm :: _00) } # [doc = "2 words"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfwm :: _01) } # [doc = "3 words"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfwm :: _10) } # [doc = "4 words"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Dacbfwm :: _11) } } # [doc = "DMA enable select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaen { # [doc = "0: DMA disabled."] _0 = 0 , # [doc = "1: DMA enabled. When DMA enabled, DMA request will be generated by original interrupts. And interrupts will not be presented on this module at the same time."] _1 = 1 , } impl From < Dmaen > for bool { # [inline (always)] fn from (variant : Dmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN` reader - DMA enable select"] pub type DmaenR = crate :: BitReader < Dmaen > ; impl DmaenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaen { match self . bits { false => Dmaen :: _0 , true => Dmaen :: _1 , } } # [doc = "DMA disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dmaen :: _0 } # [doc = "DMA enabled. When DMA enabled, DMA request will be generated by original interrupts. And interrupts will not be presented on this module at the same time."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dmaen :: _1 } } # [doc = "Field `DMAEN` writer - DMA enable select"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen > ; impl < 'a , REG > DmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DMA disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: _0) } # [doc = "DMA enabled. When DMA enabled, DMA request will be generated by original interrupts. And interrupts will not be presented on this module at the same time."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: _1) } } impl R { # [doc = "Bit 0 - DAC buffer enable"] # [inline (always)] pub fn dacbfen (& self) -> DacbfenR { DacbfenR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - DAC buffer work mode select"] # [inline (always)] pub fn dacbfmd (& self) -> DacbfmdR { DacbfmdR :: new ((self . bits >> 1) & 3) } # [doc = "Bits 3:4 - DAC buffer watermark select"] # [inline (always)] pub fn dacbfwm (& self) -> DacbfwmR { DacbfwmR :: new ((self . bits >> 3) & 3) } # [doc = "Bit 7 - DMA enable select"] # [inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DAC buffer enable"] # [inline (always)] # [must_use] pub fn dacbfen (& mut self) -> DacbfenW < C1Spec > { DacbfenW :: new (self , 0) } # [doc = "Bits 1:2 - DAC buffer work mode select"] # [inline (always)] # [must_use] pub fn dacbfmd (& mut self) -> DacbfmdW < C1Spec > { DacbfmdW :: new (self , 1) } # [doc = "Bits 3:4 - DAC buffer watermark select"] # [inline (always)] # [must_use] pub fn dacbfwm (& mut self) -> DacbfwmW < C1Spec > { DacbfwmW :: new (self , 3) } # [doc = "Bit 7 - DMA enable select"] # [inline (always)] # [must_use] pub fn dmaen (& mut self) -> DmaenW < C1Spec > { DmaenW :: new (self , 7) } } # [doc = "DAC Control Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1Spec ; impl crate :: RegisterSpec for C1Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`c1::R`](R) reader structure"] impl crate :: Readable for C1Spec { } # [doc = "`write(|w| ..)` method takes [`c1::W`](W) writer structure"] impl crate :: Writable for C1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets C1 to value 0"] impl crate :: Resettable for C1Spec { const RESET_VALUE : u8 = 0 ; }