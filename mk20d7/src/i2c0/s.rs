# [doc = "Register `S` reader"] pub type R = crate :: R < SSpec > ; # [doc = "Register `S` writer"] pub type W = crate :: W < SSpec > ; # [doc = "Receive acknowledge\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxak { # [doc = "0: Acknowledge signal was received after the completion of one byte of data transmission on the bus"] _0 = 0 , # [doc = "1: No acknowledge signal detected"] _1 = 1 , } impl From < Rxak > for bool { # [inline (always)] fn from (variant : Rxak) -> Self { variant as u8 != 0 } } # [doc = "Field `RXAK` reader - Receive acknowledge"] pub type RxakR = crate :: BitReader < Rxak > ; impl RxakR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxak { match self . bits { false => Rxak :: _0 , true => Rxak :: _1 , } } # [doc = "Acknowledge signal was received after the completion of one byte of data transmission on the bus"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Rxak :: _0 } # [doc = "No acknowledge signal detected"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Rxak :: _1 } } # [doc = "Interrupt flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iicif { # [doc = "0: No interrupt pending"] _0 = 0 , # [doc = "1: Interrupt pending"] _1 = 1 , } impl From < Iicif > for bool { # [inline (always)] fn from (variant : Iicif) -> Self { variant as u8 != 0 } } # [doc = "Field `IICIF` reader - Interrupt flag"] pub type IicifR = crate :: BitReader < Iicif > ; impl IicifR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iicif { match self . bits { false => Iicif :: _0 , true => Iicif :: _1 , } } # [doc = "No interrupt pending"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Iicif :: _0 } # [doc = "Interrupt pending"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Iicif :: _1 } } # [doc = "Field `IICIF` writer - Interrupt flag"] pub type IicifW < 'a , REG > = crate :: BitWriter < 'a , REG , Iicif > ; impl < 'a , REG > IicifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No interrupt pending"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicif :: _0) } # [doc = "Interrupt pending"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Iicif :: _1) } } # [doc = "Slave read/write\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Srw { # [doc = "0: Slave receive, master writing to slave"] _0 = 0 , # [doc = "1: Slave transmit, master reading from slave"] _1 = 1 , } impl From < Srw > for bool { # [inline (always)] fn from (variant : Srw) -> Self { variant as u8 != 0 } } # [doc = "Field `SRW` reader - Slave read/write"] pub type SrwR = crate :: BitReader < Srw > ; impl SrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Srw { match self . bits { false => Srw :: _0 , true => Srw :: _1 , } } # [doc = "Slave receive, master writing to slave"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Srw :: _0 } # [doc = "Slave transmit, master reading from slave"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Srw :: _1 } } # [doc = "Range address match\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ram { # [doc = "0: Not addressed"] _0 = 0 , # [doc = "1: Addressed as a slave"] _1 = 1 , } impl From < Ram > for bool { # [inline (always)] fn from (variant : Ram) -> Self { variant as u8 != 0 } } # [doc = "Field `RAM` reader - Range address match"] pub type RamR = crate :: BitReader < Ram > ; impl RamR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ram { match self . bits { false => Ram :: _0 , true => Ram :: _1 , } } # [doc = "Not addressed"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ram :: _0 } # [doc = "Addressed as a slave"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ram :: _1 } } # [doc = "Field `RAM` writer - Range address match"] pub type RamW < 'a , REG > = crate :: BitWriter < 'a , REG , Ram > ; impl < 'a , REG > RamW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Not addressed"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ram :: _0) } # [doc = "Addressed as a slave"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ram :: _1) } } # [doc = "Arbitration lost\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Arbl { # [doc = "0: Standard bus operation."] _0 = 0 , # [doc = "1: Loss of arbitration."] _1 = 1 , } impl From < Arbl > for bool { # [inline (always)] fn from (variant : Arbl) -> Self { variant as u8 != 0 } } # [doc = "Field `ARBL` reader - Arbitration lost"] pub type ArblR = crate :: BitReader < Arbl > ; impl ArblR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Arbl { match self . bits { false => Arbl :: _0 , true => Arbl :: _1 , } } # [doc = "Standard bus operation."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Arbl :: _0 } # [doc = "Loss of arbitration."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Arbl :: _1 } } # [doc = "Field `ARBL` writer - Arbitration lost"] pub type ArblW < 'a , REG > = crate :: BitWriter < 'a , REG , Arbl > ; impl < 'a , REG > ArblW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Standard bus operation."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Arbl :: _0) } # [doc = "Loss of arbitration."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Arbl :: _1) } } # [doc = "Bus busy\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Busy { # [doc = "0: Bus is idle"] _0 = 0 , # [doc = "1: Bus is busy"] _1 = 1 , } impl From < Busy > for bool { # [inline (always)] fn from (variant : Busy) -> Self { variant as u8 != 0 } } # [doc = "Field `BUSY` reader - Bus busy"] pub type BusyR = crate :: BitReader < Busy > ; impl BusyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Busy { match self . bits { false => Busy :: _0 , true => Busy :: _1 , } } # [doc = "Bus is idle"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Busy :: _0 } # [doc = "Bus is busy"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Busy :: _1 } } # [doc = "Addressed as a slave\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iaas { # [doc = "0: Not addressed"] _0 = 0 , # [doc = "1: Addressed as a slave"] _1 = 1 , } impl From < Iaas > for bool { # [inline (always)] fn from (variant : Iaas) -> Self { variant as u8 != 0 } } # [doc = "Field `IAAS` reader - Addressed as a slave"] pub type IaasR = crate :: BitReader < Iaas > ; impl IaasR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iaas { match self . bits { false => Iaas :: _0 , true => Iaas :: _1 , } } # [doc = "Not addressed"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Iaas :: _0 } # [doc = "Addressed as a slave"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Iaas :: _1 } } # [doc = "Field `IAAS` writer - Addressed as a slave"] pub type IaasW < 'a , REG > = crate :: BitWriter < 'a , REG , Iaas > ; impl < 'a , REG > IaasW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Not addressed"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Iaas :: _0) } # [doc = "Addressed as a slave"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Iaas :: _1) } } # [doc = "Transfer complete flag\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcf { # [doc = "0: Transfer in progress"] _0 = 0 , # [doc = "1: Transfer complete"] _1 = 1 , } impl From < Tcf > for bool { # [inline (always)] fn from (variant : Tcf) -> Self { variant as u8 != 0 } } # [doc = "Field `TCF` reader - Transfer complete flag"] pub type TcfR = crate :: BitReader < Tcf > ; impl TcfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcf { match self . bits { false => Tcf :: _0 , true => Tcf :: _1 , } } # [doc = "Transfer in progress"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tcf :: _0 } # [doc = "Transfer complete"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tcf :: _1 } } impl R { # [doc = "Bit 0 - Receive acknowledge"] # [inline (always)] pub fn rxak (& self) -> RxakR { RxakR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Interrupt flag"] # [inline (always)] pub fn iicif (& self) -> IicifR { IicifR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Slave read/write"] # [inline (always)] pub fn srw (& self) -> SrwR { SrwR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Range address match"] # [inline (always)] pub fn ram (& self) -> RamR { RamR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Arbitration lost"] # [inline (always)] pub fn arbl (& self) -> ArblR { ArblR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Bus busy"] # [inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Addressed as a slave"] # [inline (always)] pub fn iaas (& self) -> IaasR { IaasR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Transfer complete flag"] # [inline (always)] pub fn tcf (& self) -> TcfR { TcfR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Interrupt flag"] # [inline (always)] # [must_use] pub fn iicif (& mut self) -> IicifW < SSpec > { IicifW :: new (self , 1) } # [doc = "Bit 3 - Range address match"] # [inline (always)] # [must_use] pub fn ram (& mut self) -> RamW < SSpec > { RamW :: new (self , 3) } # [doc = "Bit 4 - Arbitration lost"] # [inline (always)] # [must_use] pub fn arbl (& mut self) -> ArblW < SSpec > { ArblW :: new (self , 4) } # [doc = "Bit 6 - Addressed as a slave"] # [inline (always)] # [must_use] pub fn iaas (& mut self) -> IaasW < SSpec > { IaasW :: new (self , 6) } } # [doc = "I2C Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`s::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`s::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SSpec ; impl crate :: RegisterSpec for SSpec { type Ux = u8 ; } # [doc = "`read()` method returns [`s::R`](R) reader structure"] impl crate :: Readable for SSpec { } # [doc = "`write(|w| ..)` method takes [`s::W`](W) writer structure"] impl crate :: Writable for SSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets S to value 0x80"] impl crate :: Resettable for SSpec { const RESET_VALUE : u8 = 0x80 ; }