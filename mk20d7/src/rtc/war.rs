# [doc = "Register `WAR` reader"] pub type R = crate :: R < WarSpec > ; # [doc = "Register `WAR` writer"] pub type W = crate :: W < WarSpec > ; # [doc = "Time Seconds Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tsrw { # [doc = "0: Writes to the time seconds register are ignored."] _0 = 0 , # [doc = "1: Writes to the time seconds register complete as normal."] _1 = 1 , } impl From < Tsrw > for bool { # [inline (always)] fn from (variant : Tsrw) -> Self { variant as u8 != 0 } } # [doc = "Field `TSRW` reader - Time Seconds Register Write"] pub type TsrwR = crate :: BitReader < Tsrw > ; impl TsrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsrw { match self . bits { false => Tsrw :: _0 , true => Tsrw :: _1 , } } # [doc = "Writes to the time seconds register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tsrw :: _0 } # [doc = "Writes to the time seconds register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tsrw :: _1 } } # [doc = "Field `TSRW` writer - Time Seconds Register Write"] pub type TsrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Tsrw > ; impl < 'a , REG > TsrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the time seconds register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tsrw :: _0) } # [doc = "Writes to the time seconds register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tsrw :: _1) } } # [doc = "Time Prescaler Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tprw { # [doc = "0: Writes to the time prescaler register are ignored."] _0 = 0 , # [doc = "1: Writes to the time prescaler register complete as normal."] _1 = 1 , } impl From < Tprw > for bool { # [inline (always)] fn from (variant : Tprw) -> Self { variant as u8 != 0 } } # [doc = "Field `TPRW` reader - Time Prescaler Register Write"] pub type TprwR = crate :: BitReader < Tprw > ; impl TprwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tprw { match self . bits { false => Tprw :: _0 , true => Tprw :: _1 , } } # [doc = "Writes to the time prescaler register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tprw :: _0 } # [doc = "Writes to the time prescaler register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tprw :: _1 } } # [doc = "Field `TPRW` writer - Time Prescaler Register Write"] pub type TprwW < 'a , REG > = crate :: BitWriter < 'a , REG , Tprw > ; impl < 'a , REG > TprwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the time prescaler register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tprw :: _0) } # [doc = "Writes to the time prescaler register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tprw :: _1) } } # [doc = "Time Alarm Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tarw { # [doc = "0: Writes to the time alarm register are ignored."] _0 = 0 , # [doc = "1: Writes to the time alarm register complete as normal."] _1 = 1 , } impl From < Tarw > for bool { # [inline (always)] fn from (variant : Tarw) -> Self { variant as u8 != 0 } } # [doc = "Field `TARW` reader - Time Alarm Register Write"] pub type TarwR = crate :: BitReader < Tarw > ; impl TarwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tarw { match self . bits { false => Tarw :: _0 , true => Tarw :: _1 , } } # [doc = "Writes to the time alarm register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tarw :: _0 } # [doc = "Writes to the time alarm register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tarw :: _1 } } # [doc = "Field `TARW` writer - Time Alarm Register Write"] pub type TarwW < 'a , REG > = crate :: BitWriter < 'a , REG , Tarw > ; impl < 'a , REG > TarwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the time alarm register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tarw :: _0) } # [doc = "Writes to the time alarm register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tarw :: _1) } } # [doc = "Time Compensation Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcrw { # [doc = "0: Writes to the time compensation register are ignored."] _0 = 0 , # [doc = "1: Writes to the time compensation register complete as normal."] _1 = 1 , } impl From < Tcrw > for bool { # [inline (always)] fn from (variant : Tcrw) -> Self { variant as u8 != 0 } } # [doc = "Field `TCRW` reader - Time Compensation Register Write"] pub type TcrwR = crate :: BitReader < Tcrw > ; impl TcrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcrw { match self . bits { false => Tcrw :: _0 , true => Tcrw :: _1 , } } # [doc = "Writes to the time compensation register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Tcrw :: _0 } # [doc = "Writes to the time compensation register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Tcrw :: _1 } } # [doc = "Field `TCRW` writer - Time Compensation Register Write"] pub type TcrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcrw > ; impl < 'a , REG > TcrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the time compensation register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tcrw :: _0) } # [doc = "Writes to the time compensation register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tcrw :: _1) } } # [doc = "Control Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Crw { # [doc = "0: Writes to the control register are ignored."] _0 = 0 , # [doc = "1: Writes to the control register complete as normal."] _1 = 1 , } impl From < Crw > for bool { # [inline (always)] fn from (variant : Crw) -> Self { variant as u8 != 0 } } # [doc = "Field `CRW` reader - Control Register Write"] pub type CrwR = crate :: BitReader < Crw > ; impl CrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Crw { match self . bits { false => Crw :: _0 , true => Crw :: _1 , } } # [doc = "Writes to the control register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Crw :: _0 } # [doc = "Writes to the control register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Crw :: _1 } } # [doc = "Field `CRW` writer - Control Register Write"] pub type CrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Crw > ; impl < 'a , REG > CrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the control register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Crw :: _0) } # [doc = "Writes to the control register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Crw :: _1) } } # [doc = "Status Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Srw { # [doc = "0: Writes to the status register are ignored."] _0 = 0 , # [doc = "1: Writes to the status register complete as normal."] _1 = 1 , } impl From < Srw > for bool { # [inline (always)] fn from (variant : Srw) -> Self { variant as u8 != 0 } } # [doc = "Field `SRW` reader - Status Register Write"] pub type SrwR = crate :: BitReader < Srw > ; impl SrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Srw { match self . bits { false => Srw :: _0 , true => Srw :: _1 , } } # [doc = "Writes to the status register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Srw :: _0 } # [doc = "Writes to the status register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Srw :: _1 } } # [doc = "Field `SRW` writer - Status Register Write"] pub type SrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Srw > ; impl < 'a , REG > SrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the status register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Srw :: _0) } # [doc = "Writes to the status register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Srw :: _1) } } # [doc = "Lock Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lrw { # [doc = "0: Writes to the lock register are ignored."] _0 = 0 , # [doc = "1: Writes to the lock register complete as normal."] _1 = 1 , } impl From < Lrw > for bool { # [inline (always)] fn from (variant : Lrw) -> Self { variant as u8 != 0 } } # [doc = "Field `LRW` reader - Lock Register Write"] pub type LrwR = crate :: BitReader < Lrw > ; impl LrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lrw { match self . bits { false => Lrw :: _0 , true => Lrw :: _1 , } } # [doc = "Writes to the lock register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Lrw :: _0 } # [doc = "Writes to the lock register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Lrw :: _1 } } # [doc = "Field `LRW` writer - Lock Register Write"] pub type LrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Lrw > ; impl < 'a , REG > LrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the lock register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Lrw :: _0) } # [doc = "Writes to the lock register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lrw :: _1) } } # [doc = "Interrupt Enable Register Write\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ierw { # [doc = "0: Writes to the interupt enable register are ignored."] _0 = 0 , # [doc = "1: Writes to the interrupt enable register complete as normal."] _1 = 1 , } impl From < Ierw > for bool { # [inline (always)] fn from (variant : Ierw) -> Self { variant as u8 != 0 } } # [doc = "Field `IERW` reader - Interrupt Enable Register Write"] pub type IerwR = crate :: BitReader < Ierw > ; impl IerwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ierw { match self . bits { false => Ierw :: _0 , true => Ierw :: _1 , } } # [doc = "Writes to the interupt enable register are ignored."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ierw :: _0 } # [doc = "Writes to the interrupt enable register complete as normal."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ierw :: _1 } } # [doc = "Field `IERW` writer - Interrupt Enable Register Write"] pub type IerwW < 'a , REG > = crate :: BitWriter < 'a , REG , Ierw > ; impl < 'a , REG > IerwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writes to the interupt enable register are ignored."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ierw :: _0) } # [doc = "Writes to the interrupt enable register complete as normal."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ierw :: _1) } } impl R { # [doc = "Bit 0 - Time Seconds Register Write"] # [inline (always)] pub fn tsrw (& self) -> TsrwR { TsrwR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Time Prescaler Register Write"] # [inline (always)] pub fn tprw (& self) -> TprwR { TprwR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Time Alarm Register Write"] # [inline (always)] pub fn tarw (& self) -> TarwR { TarwR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Time Compensation Register Write"] # [inline (always)] pub fn tcrw (& self) -> TcrwR { TcrwR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Control Register Write"] # [inline (always)] pub fn crw (& self) -> CrwR { CrwR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Status Register Write"] # [inline (always)] pub fn srw (& self) -> SrwR { SrwR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Lock Register Write"] # [inline (always)] pub fn lrw (& self) -> LrwR { LrwR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Enable Register Write"] # [inline (always)] pub fn ierw (& self) -> IerwR { IerwR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Time Seconds Register Write"] # [inline (always)] # [must_use] pub fn tsrw (& mut self) -> TsrwW < WarSpec > { TsrwW :: new (self , 0) } # [doc = "Bit 1 - Time Prescaler Register Write"] # [inline (always)] # [must_use] pub fn tprw (& mut self) -> TprwW < WarSpec > { TprwW :: new (self , 1) } # [doc = "Bit 2 - Time Alarm Register Write"] # [inline (always)] # [must_use] pub fn tarw (& mut self) -> TarwW < WarSpec > { TarwW :: new (self , 2) } # [doc = "Bit 3 - Time Compensation Register Write"] # [inline (always)] # [must_use] pub fn tcrw (& mut self) -> TcrwW < WarSpec > { TcrwW :: new (self , 3) } # [doc = "Bit 4 - Control Register Write"] # [inline (always)] # [must_use] pub fn crw (& mut self) -> CrwW < WarSpec > { CrwW :: new (self , 4) } # [doc = "Bit 5 - Status Register Write"] # [inline (always)] # [must_use] pub fn srw (& mut self) -> SrwW < WarSpec > { SrwW :: new (self , 5) } # [doc = "Bit 6 - Lock Register Write"] # [inline (always)] # [must_use] pub fn lrw (& mut self) -> LrwW < WarSpec > { LrwW :: new (self , 6) } # [doc = "Bit 7 - Interrupt Enable Register Write"] # [inline (always)] # [must_use] pub fn ierw (& mut self) -> IerwW < WarSpec > { IerwW :: new (self , 7) } } # [doc = "RTC Write Access Register\n\nYou can [`read`](crate::Reg::read) this register and get [`war::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`war::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WarSpec ; impl crate :: RegisterSpec for WarSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`war::R`](R) reader structure"] impl crate :: Readable for WarSpec { } # [doc = "`write(|w| ..)` method takes [`war::W`](W) writer structure"] impl crate :: Writable for WarSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets WAR to value 0xff"] impl crate :: Resettable for WarSpec { const RESET_VALUE : u32 = 0xff ; }