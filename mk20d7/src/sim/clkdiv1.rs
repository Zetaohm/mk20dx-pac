# [doc = "Register `CLKDIV1` reader"] pub type R = crate :: R < Clkdiv1Spec > ; # [doc = "Register `CLKDIV1` writer"] pub type W = crate :: W < Clkdiv1Spec > ; # [doc = "Clock 4 output divider value\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Outdiv4 { # [doc = "0: Divide-by-1."] _0000 = 0 , # [doc = "1: Divide-by-2."] _0001 = 1 , # [doc = "2: Divide-by-3."] _0010 = 2 , # [doc = "3: Divide-by-4."] _0011 = 3 , # [doc = "4: Divide-by-5."] _0100 = 4 , # [doc = "5: Divide-by-6."] _0101 = 5 , # [doc = "6: Divide-by-7."] _0110 = 6 , # [doc = "7: Divide-by-8."] _0111 = 7 , # [doc = "8: Divide-by-9."] _1000 = 8 , # [doc = "9: Divide-by-10."] _1001 = 9 , # [doc = "10: Divide-by-11."] _1010 = 10 , # [doc = "11: Divide-by-12."] _1011 = 11 , # [doc = "12: Divide-by-13."] _1100 = 12 , # [doc = "13: Divide-by-14."] _1101 = 13 , # [doc = "14: Divide-by-15."] _1110 = 14 , # [doc = "15: Divide-by-16."] _1111 = 15 , } impl From < Outdiv4 > for u8 { # [inline (always)] fn from (variant : Outdiv4) -> Self { variant as _ } } impl crate :: FieldSpec for Outdiv4 { type Ux = u8 ; } impl crate :: IsEnum for Outdiv4 { } # [doc = "Field `OUTDIV4` reader - Clock 4 output divider value"] pub type Outdiv4R = crate :: FieldReader < Outdiv4 > ; impl Outdiv4R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Outdiv4 { match self . bits { 0 => Outdiv4 :: _0000 , 1 => Outdiv4 :: _0001 , 2 => Outdiv4 :: _0010 , 3 => Outdiv4 :: _0011 , 4 => Outdiv4 :: _0100 , 5 => Outdiv4 :: _0101 , 6 => Outdiv4 :: _0110 , 7 => Outdiv4 :: _0111 , 8 => Outdiv4 :: _1000 , 9 => Outdiv4 :: _1001 , 10 => Outdiv4 :: _1010 , 11 => Outdiv4 :: _1011 , 12 => Outdiv4 :: _1100 , 13 => Outdiv4 :: _1101 , 14 => Outdiv4 :: _1110 , 15 => Outdiv4 :: _1111 , _ => unreachable ! () , } } # [doc = "Divide-by-1."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Outdiv4 :: _0000 } # [doc = "Divide-by-2."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Outdiv4 :: _0001 } # [doc = "Divide-by-3."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Outdiv4 :: _0010 } # [doc = "Divide-by-4."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Outdiv4 :: _0011 } # [doc = "Divide-by-5."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Outdiv4 :: _0100 } # [doc = "Divide-by-6."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Outdiv4 :: _0101 } # [doc = "Divide-by-7."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Outdiv4 :: _0110 } # [doc = "Divide-by-8."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Outdiv4 :: _0111 } # [doc = "Divide-by-9."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Outdiv4 :: _1000 } # [doc = "Divide-by-10."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Outdiv4 :: _1001 } # [doc = "Divide-by-11."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Outdiv4 :: _1010 } # [doc = "Divide-by-12."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Outdiv4 :: _1011 } # [doc = "Divide-by-13."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Outdiv4 :: _1100 } # [doc = "Divide-by-14."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Outdiv4 :: _1101 } # [doc = "Divide-by-15."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Outdiv4 :: _1110 } # [doc = "Divide-by-16."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Outdiv4 :: _1111 } } # [doc = "Field `OUTDIV4` writer - Clock 4 output divider value"] pub type Outdiv4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Outdiv4 , crate :: Safe > ; impl < 'a , REG > Outdiv4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divide-by-1."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0000) } # [doc = "Divide-by-2."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0001) } # [doc = "Divide-by-3."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0010) } # [doc = "Divide-by-4."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0011) } # [doc = "Divide-by-5."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0100) } # [doc = "Divide-by-6."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0101) } # [doc = "Divide-by-7."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0110) } # [doc = "Divide-by-8."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _0111) } # [doc = "Divide-by-9."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1000) } # [doc = "Divide-by-10."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1001) } # [doc = "Divide-by-11."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1010) } # [doc = "Divide-by-12."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1011) } # [doc = "Divide-by-13."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1100) } # [doc = "Divide-by-14."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1101) } # [doc = "Divide-by-15."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1110) } # [doc = "Divide-by-16."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv4 :: _1111) } } # [doc = "Clock 3 output divider value\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Outdiv3 { # [doc = "0: Divide-by-1."] _0000 = 0 , # [doc = "1: Divide-by-2."] _0001 = 1 , # [doc = "2: Divide-by-3."] _0010 = 2 , # [doc = "3: Divide-by-4."] _0011 = 3 , # [doc = "4: Divide-by-5."] _0100 = 4 , # [doc = "5: Divide-by-6."] _0101 = 5 , # [doc = "6: Divide-by-7."] _0110 = 6 , # [doc = "7: Divide-by-8."] _0111 = 7 , # [doc = "8: Divide-by-9."] _1000 = 8 , # [doc = "9: Divide-by-10."] _1001 = 9 , # [doc = "10: Divide-by-11."] _1010 = 10 , # [doc = "11: Divide-by-12."] _1011 = 11 , # [doc = "12: Divide-by-13."] _1100 = 12 , # [doc = "13: Divide-by-14."] _1101 = 13 , # [doc = "14: Divide-by-15."] _1110 = 14 , # [doc = "15: Divide-by-16."] _1111 = 15 , } impl From < Outdiv3 > for u8 { # [inline (always)] fn from (variant : Outdiv3) -> Self { variant as _ } } impl crate :: FieldSpec for Outdiv3 { type Ux = u8 ; } impl crate :: IsEnum for Outdiv3 { } # [doc = "Field `OUTDIV3` reader - Clock 3 output divider value"] pub type Outdiv3R = crate :: FieldReader < Outdiv3 > ; impl Outdiv3R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Outdiv3 { match self . bits { 0 => Outdiv3 :: _0000 , 1 => Outdiv3 :: _0001 , 2 => Outdiv3 :: _0010 , 3 => Outdiv3 :: _0011 , 4 => Outdiv3 :: _0100 , 5 => Outdiv3 :: _0101 , 6 => Outdiv3 :: _0110 , 7 => Outdiv3 :: _0111 , 8 => Outdiv3 :: _1000 , 9 => Outdiv3 :: _1001 , 10 => Outdiv3 :: _1010 , 11 => Outdiv3 :: _1011 , 12 => Outdiv3 :: _1100 , 13 => Outdiv3 :: _1101 , 14 => Outdiv3 :: _1110 , 15 => Outdiv3 :: _1111 , _ => unreachable ! () , } } # [doc = "Divide-by-1."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Outdiv3 :: _0000 } # [doc = "Divide-by-2."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Outdiv3 :: _0001 } # [doc = "Divide-by-3."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Outdiv3 :: _0010 } # [doc = "Divide-by-4."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Outdiv3 :: _0011 } # [doc = "Divide-by-5."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Outdiv3 :: _0100 } # [doc = "Divide-by-6."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Outdiv3 :: _0101 } # [doc = "Divide-by-7."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Outdiv3 :: _0110 } # [doc = "Divide-by-8."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Outdiv3 :: _0111 } # [doc = "Divide-by-9."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Outdiv3 :: _1000 } # [doc = "Divide-by-10."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Outdiv3 :: _1001 } # [doc = "Divide-by-11."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Outdiv3 :: _1010 } # [doc = "Divide-by-12."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Outdiv3 :: _1011 } # [doc = "Divide-by-13."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Outdiv3 :: _1100 } # [doc = "Divide-by-14."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Outdiv3 :: _1101 } # [doc = "Divide-by-15."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Outdiv3 :: _1110 } # [doc = "Divide-by-16."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Outdiv3 :: _1111 } } # [doc = "Field `OUTDIV3` writer - Clock 3 output divider value"] pub type Outdiv3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Outdiv3 , crate :: Safe > ; impl < 'a , REG > Outdiv3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divide-by-1."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0000) } # [doc = "Divide-by-2."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0001) } # [doc = "Divide-by-3."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0010) } # [doc = "Divide-by-4."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0011) } # [doc = "Divide-by-5."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0100) } # [doc = "Divide-by-6."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0101) } # [doc = "Divide-by-7."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0110) } # [doc = "Divide-by-8."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _0111) } # [doc = "Divide-by-9."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1000) } # [doc = "Divide-by-10."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1001) } # [doc = "Divide-by-11."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1010) } # [doc = "Divide-by-12."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1011) } # [doc = "Divide-by-13."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1100) } # [doc = "Divide-by-14."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1101) } # [doc = "Divide-by-15."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1110) } # [doc = "Divide-by-16."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv3 :: _1111) } } # [doc = "Clock 2 output divider value\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Outdiv2 { # [doc = "0: Divide-by-1."] _0000 = 0 , # [doc = "1: Divide-by-2."] _0001 = 1 , # [doc = "2: Divide-by-3."] _0010 = 2 , # [doc = "3: Divide-by-4."] _0011 = 3 , # [doc = "4: Divide-by-5."] _0100 = 4 , # [doc = "5: Divide-by-6."] _0101 = 5 , # [doc = "6: Divide-by-7."] _0110 = 6 , # [doc = "7: Divide-by-8."] _0111 = 7 , # [doc = "8: Divide-by-9."] _1000 = 8 , # [doc = "9: Divide-by-10."] _1001 = 9 , # [doc = "10: Divide-by-11."] _1010 = 10 , # [doc = "11: Divide-by-12."] _1011 = 11 , # [doc = "12: Divide-by-13."] _1100 = 12 , # [doc = "13: Divide-by-14."] _1101 = 13 , # [doc = "14: Divide-by-15."] _1110 = 14 , # [doc = "15: Divide-by-16."] _1111 = 15 , } impl From < Outdiv2 > for u8 { # [inline (always)] fn from (variant : Outdiv2) -> Self { variant as _ } } impl crate :: FieldSpec for Outdiv2 { type Ux = u8 ; } impl crate :: IsEnum for Outdiv2 { } # [doc = "Field `OUTDIV2` reader - Clock 2 output divider value"] pub type Outdiv2R = crate :: FieldReader < Outdiv2 > ; impl Outdiv2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Outdiv2 { match self . bits { 0 => Outdiv2 :: _0000 , 1 => Outdiv2 :: _0001 , 2 => Outdiv2 :: _0010 , 3 => Outdiv2 :: _0011 , 4 => Outdiv2 :: _0100 , 5 => Outdiv2 :: _0101 , 6 => Outdiv2 :: _0110 , 7 => Outdiv2 :: _0111 , 8 => Outdiv2 :: _1000 , 9 => Outdiv2 :: _1001 , 10 => Outdiv2 :: _1010 , 11 => Outdiv2 :: _1011 , 12 => Outdiv2 :: _1100 , 13 => Outdiv2 :: _1101 , 14 => Outdiv2 :: _1110 , 15 => Outdiv2 :: _1111 , _ => unreachable ! () , } } # [doc = "Divide-by-1."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Outdiv2 :: _0000 } # [doc = "Divide-by-2."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Outdiv2 :: _0001 } # [doc = "Divide-by-3."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Outdiv2 :: _0010 } # [doc = "Divide-by-4."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Outdiv2 :: _0011 } # [doc = "Divide-by-5."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Outdiv2 :: _0100 } # [doc = "Divide-by-6."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Outdiv2 :: _0101 } # [doc = "Divide-by-7."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Outdiv2 :: _0110 } # [doc = "Divide-by-8."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Outdiv2 :: _0111 } # [doc = "Divide-by-9."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Outdiv2 :: _1000 } # [doc = "Divide-by-10."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Outdiv2 :: _1001 } # [doc = "Divide-by-11."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Outdiv2 :: _1010 } # [doc = "Divide-by-12."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Outdiv2 :: _1011 } # [doc = "Divide-by-13."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Outdiv2 :: _1100 } # [doc = "Divide-by-14."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Outdiv2 :: _1101 } # [doc = "Divide-by-15."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Outdiv2 :: _1110 } # [doc = "Divide-by-16."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Outdiv2 :: _1111 } } # [doc = "Field `OUTDIV2` writer - Clock 2 output divider value"] pub type Outdiv2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Outdiv2 , crate :: Safe > ; impl < 'a , REG > Outdiv2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divide-by-1."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0000) } # [doc = "Divide-by-2."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0001) } # [doc = "Divide-by-3."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0010) } # [doc = "Divide-by-4."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0011) } # [doc = "Divide-by-5."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0100) } # [doc = "Divide-by-6."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0101) } # [doc = "Divide-by-7."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0110) } # [doc = "Divide-by-8."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _0111) } # [doc = "Divide-by-9."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1000) } # [doc = "Divide-by-10."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1001) } # [doc = "Divide-by-11."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1010) } # [doc = "Divide-by-12."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1011) } # [doc = "Divide-by-13."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1100) } # [doc = "Divide-by-14."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1101) } # [doc = "Divide-by-15."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1110) } # [doc = "Divide-by-16."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv2 :: _1111) } } # [doc = "Clock 1 output divider value\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Outdiv1 { # [doc = "0: Divide-by-1."] _0000 = 0 , # [doc = "1: Divide-by-2."] _0001 = 1 , # [doc = "2: Divide-by-3."] _0010 = 2 , # [doc = "3: Divide-by-4."] _0011 = 3 , # [doc = "4: Divide-by-5."] _0100 = 4 , # [doc = "5: Divide-by-6."] _0101 = 5 , # [doc = "6: Divide-by-7."] _0110 = 6 , # [doc = "7: Divide-by-8."] _0111 = 7 , # [doc = "8: Divide-by-9."] _1000 = 8 , # [doc = "9: Divide-by-10."] _1001 = 9 , # [doc = "10: Divide-by-11."] _1010 = 10 , # [doc = "11: Divide-by-12."] _1011 = 11 , # [doc = "12: Divide-by-13."] _1100 = 12 , # [doc = "13: Divide-by-14."] _1101 = 13 , # [doc = "14: Divide-by-15."] _1110 = 14 , # [doc = "15: Divide-by-16."] _1111 = 15 , } impl From < Outdiv1 > for u8 { # [inline (always)] fn from (variant : Outdiv1) -> Self { variant as _ } } impl crate :: FieldSpec for Outdiv1 { type Ux = u8 ; } impl crate :: IsEnum for Outdiv1 { } # [doc = "Field `OUTDIV1` reader - Clock 1 output divider value"] pub type Outdiv1R = crate :: FieldReader < Outdiv1 > ; impl Outdiv1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Outdiv1 { match self . bits { 0 => Outdiv1 :: _0000 , 1 => Outdiv1 :: _0001 , 2 => Outdiv1 :: _0010 , 3 => Outdiv1 :: _0011 , 4 => Outdiv1 :: _0100 , 5 => Outdiv1 :: _0101 , 6 => Outdiv1 :: _0110 , 7 => Outdiv1 :: _0111 , 8 => Outdiv1 :: _1000 , 9 => Outdiv1 :: _1001 , 10 => Outdiv1 :: _1010 , 11 => Outdiv1 :: _1011 , 12 => Outdiv1 :: _1100 , 13 => Outdiv1 :: _1101 , 14 => Outdiv1 :: _1110 , 15 => Outdiv1 :: _1111 , _ => unreachable ! () , } } # [doc = "Divide-by-1."] # [inline (always)] pub fn is_0000 (& self) -> bool { * self == Outdiv1 :: _0000 } # [doc = "Divide-by-2."] # [inline (always)] pub fn is_0001 (& self) -> bool { * self == Outdiv1 :: _0001 } # [doc = "Divide-by-3."] # [inline (always)] pub fn is_0010 (& self) -> bool { * self == Outdiv1 :: _0010 } # [doc = "Divide-by-4."] # [inline (always)] pub fn is_0011 (& self) -> bool { * self == Outdiv1 :: _0011 } # [doc = "Divide-by-5."] # [inline (always)] pub fn is_0100 (& self) -> bool { * self == Outdiv1 :: _0100 } # [doc = "Divide-by-6."] # [inline (always)] pub fn is_0101 (& self) -> bool { * self == Outdiv1 :: _0101 } # [doc = "Divide-by-7."] # [inline (always)] pub fn is_0110 (& self) -> bool { * self == Outdiv1 :: _0110 } # [doc = "Divide-by-8."] # [inline (always)] pub fn is_0111 (& self) -> bool { * self == Outdiv1 :: _0111 } # [doc = "Divide-by-9."] # [inline (always)] pub fn is_1000 (& self) -> bool { * self == Outdiv1 :: _1000 } # [doc = "Divide-by-10."] # [inline (always)] pub fn is_1001 (& self) -> bool { * self == Outdiv1 :: _1001 } # [doc = "Divide-by-11."] # [inline (always)] pub fn is_1010 (& self) -> bool { * self == Outdiv1 :: _1010 } # [doc = "Divide-by-12."] # [inline (always)] pub fn is_1011 (& self) -> bool { * self == Outdiv1 :: _1011 } # [doc = "Divide-by-13."] # [inline (always)] pub fn is_1100 (& self) -> bool { * self == Outdiv1 :: _1100 } # [doc = "Divide-by-14."] # [inline (always)] pub fn is_1101 (& self) -> bool { * self == Outdiv1 :: _1101 } # [doc = "Divide-by-15."] # [inline (always)] pub fn is_1110 (& self) -> bool { * self == Outdiv1 :: _1110 } # [doc = "Divide-by-16."] # [inline (always)] pub fn is_1111 (& self) -> bool { * self == Outdiv1 :: _1111 } } # [doc = "Field `OUTDIV1` writer - Clock 1 output divider value"] pub type Outdiv1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Outdiv1 , crate :: Safe > ; impl < 'a , REG > Outdiv1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divide-by-1."] # [inline (always)] pub fn _0000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0000) } # [doc = "Divide-by-2."] # [inline (always)] pub fn _0001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0001) } # [doc = "Divide-by-3."] # [inline (always)] pub fn _0010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0010) } # [doc = "Divide-by-4."] # [inline (always)] pub fn _0011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0011) } # [doc = "Divide-by-5."] # [inline (always)] pub fn _0100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0100) } # [doc = "Divide-by-6."] # [inline (always)] pub fn _0101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0101) } # [doc = "Divide-by-7."] # [inline (always)] pub fn _0110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0110) } # [doc = "Divide-by-8."] # [inline (always)] pub fn _0111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _0111) } # [doc = "Divide-by-9."] # [inline (always)] pub fn _1000 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1000) } # [doc = "Divide-by-10."] # [inline (always)] pub fn _1001 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1001) } # [doc = "Divide-by-11."] # [inline (always)] pub fn _1010 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1010) } # [doc = "Divide-by-12."] # [inline (always)] pub fn _1011 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1011) } # [doc = "Divide-by-13."] # [inline (always)] pub fn _1100 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1100) } # [doc = "Divide-by-14."] # [inline (always)] pub fn _1101 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1101) } # [doc = "Divide-by-15."] # [inline (always)] pub fn _1110 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1110) } # [doc = "Divide-by-16."] # [inline (always)] pub fn _1111 (self) -> & 'a mut crate :: W < REG > { self . variant (Outdiv1 :: _1111) } } impl R { # [doc = "Bits 16:19 - Clock 4 output divider value"] # [inline (always)] pub fn outdiv4 (& self) -> Outdiv4R { Outdiv4R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Clock 3 output divider value"] # [inline (always)] pub fn outdiv3 (& self) -> Outdiv3R { Outdiv3R :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 24:27 - Clock 2 output divider value"] # [inline (always)] pub fn outdiv2 (& self) -> Outdiv2R { Outdiv2R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:31 - Clock 1 output divider value"] # [inline (always)] pub fn outdiv1 (& self) -> Outdiv1R { Outdiv1R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Bits 16:19 - Clock 4 output divider value"] # [inline (always)] # [must_use] pub fn outdiv4 (& mut self) -> Outdiv4W < Clkdiv1Spec > { Outdiv4W :: new (self , 16) } # [doc = "Bits 20:23 - Clock 3 output divider value"] # [inline (always)] # [must_use] pub fn outdiv3 (& mut self) -> Outdiv3W < Clkdiv1Spec > { Outdiv3W :: new (self , 20) } # [doc = "Bits 24:27 - Clock 2 output divider value"] # [inline (always)] # [must_use] pub fn outdiv2 (& mut self) -> Outdiv2W < Clkdiv1Spec > { Outdiv2W :: new (self , 24) } # [doc = "Bits 28:31 - Clock 1 output divider value"] # [inline (always)] # [must_use] pub fn outdiv1 (& mut self) -> Outdiv1W < Clkdiv1Spec > { Outdiv1W :: new (self , 28) } } # [doc = "System Clock Divider Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`clkdiv1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkdiv1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Clkdiv1Spec ; impl crate :: RegisterSpec for Clkdiv1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`clkdiv1::R`](R) reader structure"] impl crate :: Readable for Clkdiv1Spec { } # [doc = "`write(|w| ..)` method takes [`clkdiv1::W`](W) writer structure"] impl crate :: Writable for Clkdiv1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLKDIV1 to value 0"] impl crate :: Resettable for Clkdiv1Spec { const RESET_VALUE : u32 = 0 ; }