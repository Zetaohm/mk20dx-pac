# [doc = "Register `CFSR` reader"] pub type R = crate :: R < CfsrSpec > ; # [doc = "Register `CFSR` writer"] pub type W = crate :: W < CfsrSpec > ; # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iaccviol { # [doc = "0: no instruction access violation fault"] _0 = 0 , # [doc = "1: the processor attempted an instruction fetch from a location that does not permit execution"] _1 = 1 , } impl From < Iaccviol > for bool { # [inline (always)] fn from (variant : Iaccviol) -> Self { variant as u8 != 0 } } # [doc = "Field `IACCVIOL` reader - no description available"] pub type IaccviolR = crate :: BitReader < Iaccviol > ; impl IaccviolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iaccviol { match self . bits { false => Iaccviol :: _0 , true => Iaccviol :: _1 , } } # [doc = "no instruction access violation fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Iaccviol :: _0 } # [doc = "the processor attempted an instruction fetch from a location that does not permit execution"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Iaccviol :: _1 } } # [doc = "Field `IACCVIOL` writer - no description available"] pub type IaccviolW < 'a , REG > = crate :: BitWriter < 'a , REG , Iaccviol > ; impl < 'a , REG > IaccviolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no instruction access violation fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Iaccviol :: _0) } # [doc = "the processor attempted an instruction fetch from a location that does not permit execution"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Iaccviol :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Daccviol { # [doc = "0: no data access violation fault"] _0 = 0 , # [doc = "1: the processor attempted a load or store at a location that does not permit the operation"] _1 = 1 , } impl From < Daccviol > for bool { # [inline (always)] fn from (variant : Daccviol) -> Self { variant as u8 != 0 } } # [doc = "Field `DACCVIOL` reader - no description available"] pub type DaccviolR = crate :: BitReader < Daccviol > ; impl DaccviolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Daccviol { match self . bits { false => Daccviol :: _0 , true => Daccviol :: _1 , } } # [doc = "no data access violation fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Daccviol :: _0 } # [doc = "the processor attempted a load or store at a location that does not permit the operation"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Daccviol :: _1 } } # [doc = "Field `DACCVIOL` writer - no description available"] pub type DaccviolW < 'a , REG > = crate :: BitWriter < 'a , REG , Daccviol > ; impl < 'a , REG > DaccviolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no data access violation fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Daccviol :: _0) } # [doc = "the processor attempted a load or store at a location that does not permit the operation"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Daccviol :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Munstkerr { # [doc = "0: no unstacking fault"] _0 = 0 , # [doc = "1: unstack for an exception return has caused one or more access violations"] _1 = 1 , } impl From < Munstkerr > for bool { # [inline (always)] fn from (variant : Munstkerr) -> Self { variant as u8 != 0 } } # [doc = "Field `MUNSTKERR` reader - no description available"] pub type MunstkerrR = crate :: BitReader < Munstkerr > ; impl MunstkerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Munstkerr { match self . bits { false => Munstkerr :: _0 , true => Munstkerr :: _1 , } } # [doc = "no unstacking fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Munstkerr :: _0 } # [doc = "unstack for an exception return has caused one or more access violations"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Munstkerr :: _1 } } # [doc = "Field `MUNSTKERR` writer - no description available"] pub type MunstkerrW < 'a , REG > = crate :: BitWriter < 'a , REG , Munstkerr > ; impl < 'a , REG > MunstkerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no unstacking fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Munstkerr :: _0) } # [doc = "unstack for an exception return has caused one or more access violations"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Munstkerr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mstkerr { # [doc = "0: no stacking fault"] _0 = 0 , # [doc = "1: stacking for an exception entry has caused one or more access violations"] _1 = 1 , } impl From < Mstkerr > for bool { # [inline (always)] fn from (variant : Mstkerr) -> Self { variant as u8 != 0 } } # [doc = "Field `MSTKERR` reader - no description available"] pub type MstkerrR = crate :: BitReader < Mstkerr > ; impl MstkerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mstkerr { match self . bits { false => Mstkerr :: _0 , true => Mstkerr :: _1 , } } # [doc = "no stacking fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Mstkerr :: _0 } # [doc = "stacking for an exception entry has caused one or more access violations"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Mstkerr :: _1 } } # [doc = "Field `MSTKERR` writer - no description available"] pub type MstkerrW < 'a , REG > = crate :: BitWriter < 'a , REG , Mstkerr > ; impl < 'a , REG > MstkerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no stacking fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mstkerr :: _0) } # [doc = "stacking for an exception entry has caused one or more access violations"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mstkerr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mlsperr { # [doc = "0: No MemManage fault occurred during floating-point lazy state preservation"] _0 = 0 , # [doc = "1: A MemManage fault occurred during floating-point lazy state preservation"] _1 = 1 , } impl From < Mlsperr > for bool { # [inline (always)] fn from (variant : Mlsperr) -> Self { variant as u8 != 0 } } # [doc = "Field `MLSPERR` reader - no description available"] pub type MlsperrR = crate :: BitReader < Mlsperr > ; impl MlsperrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mlsperr { match self . bits { false => Mlsperr :: _0 , true => Mlsperr :: _1 , } } # [doc = "No MemManage fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Mlsperr :: _0 } # [doc = "A MemManage fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Mlsperr :: _1 } } # [doc = "Field `MLSPERR` writer - no description available"] pub type MlsperrW < 'a , REG > = crate :: BitWriter < 'a , REG , Mlsperr > ; impl < 'a , REG > MlsperrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No MemManage fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mlsperr :: _0) } # [doc = "A MemManage fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mlsperr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mmarvalid { # [doc = "0: value in MMAR is not a valid fault address"] _0 = 0 , # [doc = "1: MMAR holds a valid fault address"] _1 = 1 , } impl From < Mmarvalid > for bool { # [inline (always)] fn from (variant : Mmarvalid) -> Self { variant as u8 != 0 } } # [doc = "Field `MMARVALID` reader - no description available"] pub type MmarvalidR = crate :: BitReader < Mmarvalid > ; impl MmarvalidR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mmarvalid { match self . bits { false => Mmarvalid :: _0 , true => Mmarvalid :: _1 , } } # [doc = "value in MMAR is not a valid fault address"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Mmarvalid :: _0 } # [doc = "MMAR holds a valid fault address"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Mmarvalid :: _1 } } # [doc = "Field `MMARVALID` writer - no description available"] pub type MmarvalidW < 'a , REG > = crate :: BitWriter < 'a , REG , Mmarvalid > ; impl < 'a , REG > MmarvalidW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "value in MMAR is not a valid fault address"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mmarvalid :: _0) } # [doc = "MMAR holds a valid fault address"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mmarvalid :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ibuserr { # [doc = "0: no instruction bus error"] _0 = 0 , # [doc = "1: instruction bus error"] _1 = 1 , } impl From < Ibuserr > for bool { # [inline (always)] fn from (variant : Ibuserr) -> Self { variant as u8 != 0 } } # [doc = "Field `IBUSERR` reader - no description available"] pub type IbuserrR = crate :: BitReader < Ibuserr > ; impl IbuserrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ibuserr { match self . bits { false => Ibuserr :: _0 , true => Ibuserr :: _1 , } } # [doc = "no instruction bus error"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Ibuserr :: _0 } # [doc = "instruction bus error"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Ibuserr :: _1 } } # [doc = "Field `IBUSERR` writer - no description available"] pub type IbuserrW < 'a , REG > = crate :: BitWriter < 'a , REG , Ibuserr > ; impl < 'a , REG > IbuserrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no instruction bus error"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ibuserr :: _0) } # [doc = "instruction bus error"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ibuserr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Preciserr { # [doc = "0: no precise data bus error"] _0 = 0 , # [doc = "1: a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault"] _1 = 1 , } impl From < Preciserr > for bool { # [inline (always)] fn from (variant : Preciserr) -> Self { variant as u8 != 0 } } # [doc = "Field `PRECISERR` reader - no description available"] pub type PreciserrR = crate :: BitReader < Preciserr > ; impl PreciserrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Preciserr { match self . bits { false => Preciserr :: _0 , true => Preciserr :: _1 , } } # [doc = "no precise data bus error"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Preciserr :: _0 } # [doc = "a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Preciserr :: _1 } } # [doc = "Field `PRECISERR` writer - no description available"] pub type PreciserrW < 'a , REG > = crate :: BitWriter < 'a , REG , Preciserr > ; impl < 'a , REG > PreciserrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no precise data bus error"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Preciserr :: _0) } # [doc = "a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Preciserr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Impreciserr { # [doc = "0: no imprecise data bus error"] _0 = 0 , # [doc = "1: a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error"] _1 = 1 , } impl From < Impreciserr > for bool { # [inline (always)] fn from (variant : Impreciserr) -> Self { variant as u8 != 0 } } # [doc = "Field `IMPRECISERR` reader - no description available"] pub type ImpreciserrR = crate :: BitReader < Impreciserr > ; impl ImpreciserrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Impreciserr { match self . bits { false => Impreciserr :: _0 , true => Impreciserr :: _1 , } } # [doc = "no imprecise data bus error"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Impreciserr :: _0 } # [doc = "a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Impreciserr :: _1 } } # [doc = "Field `IMPRECISERR` writer - no description available"] pub type ImpreciserrW < 'a , REG > = crate :: BitWriter < 'a , REG , Impreciserr > ; impl < 'a , REG > ImpreciserrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no imprecise data bus error"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Impreciserr :: _0) } # [doc = "a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Impreciserr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Unstkerr { # [doc = "0: no unstacking fault"] _0 = 0 , # [doc = "1: unstack for an exception return has caused one or more BusFaults"] _1 = 1 , } impl From < Unstkerr > for bool { # [inline (always)] fn from (variant : Unstkerr) -> Self { variant as u8 != 0 } } # [doc = "Field `UNSTKERR` reader - no description available"] pub type UnstkerrR = crate :: BitReader < Unstkerr > ; impl UnstkerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Unstkerr { match self . bits { false => Unstkerr :: _0 , true => Unstkerr :: _1 , } } # [doc = "no unstacking fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Unstkerr :: _0 } # [doc = "unstack for an exception return has caused one or more BusFaults"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Unstkerr :: _1 } } # [doc = "Field `UNSTKERR` writer - no description available"] pub type UnstkerrW < 'a , REG > = crate :: BitWriter < 'a , REG , Unstkerr > ; impl < 'a , REG > UnstkerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no unstacking fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Unstkerr :: _0) } # [doc = "unstack for an exception return has caused one or more BusFaults"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Unstkerr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Stkerr { # [doc = "0: no stacking fault"] _0 = 0 , # [doc = "1: stacking for an exception entry has caused one or more BusFaults"] _1 = 1 , } impl From < Stkerr > for bool { # [inline (always)] fn from (variant : Stkerr) -> Self { variant as u8 != 0 } } # [doc = "Field `STKERR` reader - no description available"] pub type StkerrR = crate :: BitReader < Stkerr > ; impl StkerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Stkerr { match self . bits { false => Stkerr :: _0 , true => Stkerr :: _1 , } } # [doc = "no stacking fault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Stkerr :: _0 } # [doc = "stacking for an exception entry has caused one or more BusFaults"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Stkerr :: _1 } } # [doc = "Field `STKERR` writer - no description available"] pub type StkerrW < 'a , REG > = crate :: BitWriter < 'a , REG , Stkerr > ; impl < 'a , REG > StkerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no stacking fault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Stkerr :: _0) } # [doc = "stacking for an exception entry has caused one or more BusFaults"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Stkerr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lsperr { # [doc = "0: No bus fault occurred during floating-point lazy state preservation"] _0 = 0 , # [doc = "1: A bus fault occurred during floating-point lazy state preservation"] _1 = 1 , } impl From < Lsperr > for bool { # [inline (always)] fn from (variant : Lsperr) -> Self { variant as u8 != 0 } } # [doc = "Field `LSPERR` reader - no description available"] pub type LsperrR = crate :: BitReader < Lsperr > ; impl LsperrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lsperr { match self . bits { false => Lsperr :: _0 , true => Lsperr :: _1 , } } # [doc = "No bus fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Lsperr :: _0 } # [doc = "A bus fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Lsperr :: _1 } } # [doc = "Field `LSPERR` writer - no description available"] pub type LsperrW < 'a , REG > = crate :: BitWriter < 'a , REG , Lsperr > ; impl < 'a , REG > LsperrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No bus fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Lsperr :: _0) } # [doc = "A bus fault occurred during floating-point lazy state preservation"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lsperr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bfarvalid { # [doc = "0: value in BFAR is not a valid fault address"] _0 = 0 , # [doc = "1: BFAR holds a valid fault address"] _1 = 1 , } impl From < Bfarvalid > for bool { # [inline (always)] fn from (variant : Bfarvalid) -> Self { variant as u8 != 0 } } # [doc = "Field `BFARVALID` reader - no description available"] pub type BfarvalidR = crate :: BitReader < Bfarvalid > ; impl BfarvalidR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bfarvalid { match self . bits { false => Bfarvalid :: _0 , true => Bfarvalid :: _1 , } } # [doc = "value in BFAR is not a valid fault address"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Bfarvalid :: _0 } # [doc = "BFAR holds a valid fault address"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Bfarvalid :: _1 } } # [doc = "Field `BFARVALID` writer - no description available"] pub type BfarvalidW < 'a , REG > = crate :: BitWriter < 'a , REG , Bfarvalid > ; impl < 'a , REG > BfarvalidW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "value in BFAR is not a valid fault address"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Bfarvalid :: _0) } # [doc = "BFAR holds a valid fault address"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Bfarvalid :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Undefinstr { # [doc = "0: no undefined instruction UsageFault"] _0 = 0 , # [doc = "1: the processor has attempted to execute an undefined instruction"] _1 = 1 , } impl From < Undefinstr > for bool { # [inline (always)] fn from (variant : Undefinstr) -> Self { variant as u8 != 0 } } # [doc = "Field `UNDEFINSTR` reader - no description available"] pub type UndefinstrR = crate :: BitReader < Undefinstr > ; impl UndefinstrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Undefinstr { match self . bits { false => Undefinstr :: _0 , true => Undefinstr :: _1 , } } # [doc = "no undefined instruction UsageFault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Undefinstr :: _0 } # [doc = "the processor has attempted to execute an undefined instruction"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Undefinstr :: _1 } } # [doc = "Field `UNDEFINSTR` writer - no description available"] pub type UndefinstrW < 'a , REG > = crate :: BitWriter < 'a , REG , Undefinstr > ; impl < 'a , REG > UndefinstrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no undefined instruction UsageFault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Undefinstr :: _0) } # [doc = "the processor has attempted to execute an undefined instruction"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Undefinstr :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Invstate { # [doc = "0: no invalid state UsageFault"] _0 = 0 , # [doc = "1: the processor has attempted to execute an instruction that makes illegal use of the EPSR"] _1 = 1 , } impl From < Invstate > for bool { # [inline (always)] fn from (variant : Invstate) -> Self { variant as u8 != 0 } } # [doc = "Field `INVSTATE` reader - no description available"] pub type InvstateR = crate :: BitReader < Invstate > ; impl InvstateR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Invstate { match self . bits { false => Invstate :: _0 , true => Invstate :: _1 , } } # [doc = "no invalid state UsageFault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Invstate :: _0 } # [doc = "the processor has attempted to execute an instruction that makes illegal use of the EPSR"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Invstate :: _1 } } # [doc = "Field `INVSTATE` writer - no description available"] pub type InvstateW < 'a , REG > = crate :: BitWriter < 'a , REG , Invstate > ; impl < 'a , REG > InvstateW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no invalid state UsageFault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Invstate :: _0) } # [doc = "the processor has attempted to execute an instruction that makes illegal use of the EPSR"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Invstate :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Invpc { # [doc = "0: no invalid PC load UsageFault"] _0 = 0 , # [doc = "1: the processor has attempted an illegal load of EXC_RETURN to the PC"] _1 = 1 , } impl From < Invpc > for bool { # [inline (always)] fn from (variant : Invpc) -> Self { variant as u8 != 0 } } # [doc = "Field `INVPC` reader - no description available"] pub type InvpcR = crate :: BitReader < Invpc > ; impl InvpcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Invpc { match self . bits { false => Invpc :: _0 , true => Invpc :: _1 , } } # [doc = "no invalid PC load UsageFault"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Invpc :: _0 } # [doc = "the processor has attempted an illegal load of EXC_RETURN to the PC"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Invpc :: _1 } } # [doc = "Field `INVPC` writer - no description available"] pub type InvpcW < 'a , REG > = crate :: BitWriter < 'a , REG , Invpc > ; impl < 'a , REG > InvpcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no invalid PC load UsageFault"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Invpc :: _0) } # [doc = "the processor has attempted an illegal load of EXC_RETURN to the PC"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Invpc :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Nocp { # [doc = "0: no UsageFault caused by attempting to access a coprocessor"] _0 = 0 , # [doc = "1: the processor has attempted to access a coprocessor"] _1 = 1 , } impl From < Nocp > for bool { # [inline (always)] fn from (variant : Nocp) -> Self { variant as u8 != 0 } } # [doc = "Field `NOCP` reader - no description available"] pub type NocpR = crate :: BitReader < Nocp > ; impl NocpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Nocp { match self . bits { false => Nocp :: _0 , true => Nocp :: _1 , } } # [doc = "no UsageFault caused by attempting to access a coprocessor"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Nocp :: _0 } # [doc = "the processor has attempted to access a coprocessor"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Nocp :: _1 } } # [doc = "Field `NOCP` writer - no description available"] pub type NocpW < 'a , REG > = crate :: BitWriter < 'a , REG , Nocp > ; impl < 'a , REG > NocpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no UsageFault caused by attempting to access a coprocessor"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Nocp :: _0) } # [doc = "the processor has attempted to access a coprocessor"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Nocp :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Unaligned { # [doc = "0: no unaligned access fault, or unaligned access trapping not enabled"] _0 = 0 , # [doc = "1: the processor has made an unaligned memory access"] _1 = 1 , } impl From < Unaligned > for bool { # [inline (always)] fn from (variant : Unaligned) -> Self { variant as u8 != 0 } } # [doc = "Field `UNALIGNED` reader - no description available"] pub type UnalignedR = crate :: BitReader < Unaligned > ; impl UnalignedR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Unaligned { match self . bits { false => Unaligned :: _0 , true => Unaligned :: _1 , } } # [doc = "no unaligned access fault, or unaligned access trapping not enabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Unaligned :: _0 } # [doc = "the processor has made an unaligned memory access"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Unaligned :: _1 } } # [doc = "Field `UNALIGNED` writer - no description available"] pub type UnalignedW < 'a , REG > = crate :: BitWriter < 'a , REG , Unaligned > ; impl < 'a , REG > UnalignedW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no unaligned access fault, or unaligned access trapping not enabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Unaligned :: _0) } # [doc = "the processor has made an unaligned memory access"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Unaligned :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Divbyzero { # [doc = "0: no divide by zero fault, or divide by zero trapping not enabled"] _0 = 0 , # [doc = "1: the processor has executed an SDIV or UDIV instruction with a divisor of 0"] _1 = 1 , } impl From < Divbyzero > for bool { # [inline (always)] fn from (variant : Divbyzero) -> Self { variant as u8 != 0 } } # [doc = "Field `DIVBYZERO` reader - no description available"] pub type DivbyzeroR = crate :: BitReader < Divbyzero > ; impl DivbyzeroR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Divbyzero { match self . bits { false => Divbyzero :: _0 , true => Divbyzero :: _1 , } } # [doc = "no divide by zero fault, or divide by zero trapping not enabled"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Divbyzero :: _0 } # [doc = "the processor has executed an SDIV or UDIV instruction with a divisor of 0"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Divbyzero :: _1 } } # [doc = "Field `DIVBYZERO` writer - no description available"] pub type DivbyzeroW < 'a , REG > = crate :: BitWriter < 'a , REG , Divbyzero > ; impl < 'a , REG > DivbyzeroW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "no divide by zero fault, or divide by zero trapping not enabled"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Divbyzero :: _0) } # [doc = "the processor has executed an SDIV or UDIV instruction with a divisor of 0"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Divbyzero :: _1) } } impl R { # [doc = "Bit 0 - no description available"] # [inline (always)] pub fn iaccviol (& self) -> IaccviolR { IaccviolR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] pub fn daccviol (& self) -> DaccviolR { DaccviolR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - no description available"] # [inline (always)] pub fn munstkerr (& self) -> MunstkerrR { MunstkerrR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - no description available"] # [inline (always)] pub fn mstkerr (& self) -> MstkerrR { MstkerrR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - no description available"] # [inline (always)] pub fn mlsperr (& self) -> MlsperrR { MlsperrR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - no description available"] # [inline (always)] pub fn mmarvalid (& self) -> MmarvalidR { MmarvalidR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - no description available"] # [inline (always)] pub fn ibuserr (& self) -> IbuserrR { IbuserrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - no description available"] # [inline (always)] pub fn preciserr (& self) -> PreciserrR { PreciserrR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - no description available"] # [inline (always)] pub fn impreciserr (& self) -> ImpreciserrR { ImpreciserrR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - no description available"] # [inline (always)] pub fn unstkerr (& self) -> UnstkerrR { UnstkerrR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - no description available"] # [inline (always)] pub fn stkerr (& self) -> StkerrR { StkerrR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - no description available"] # [inline (always)] pub fn lsperr (& self) -> LsperrR { LsperrR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 15 - no description available"] # [inline (always)] pub fn bfarvalid (& self) -> BfarvalidR { BfarvalidR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - no description available"] # [inline (always)] pub fn undefinstr (& self) -> UndefinstrR { UndefinstrR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - no description available"] # [inline (always)] pub fn invstate (& self) -> InvstateR { InvstateR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - no description available"] # [inline (always)] pub fn invpc (& self) -> InvpcR { InvpcR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - no description available"] # [inline (always)] pub fn nocp (& self) -> NocpR { NocpR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - no description available"] # [inline (always)] pub fn unaligned (& self) -> UnalignedR { UnalignedR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - no description available"] # [inline (always)] pub fn divbyzero (& self) -> DivbyzeroR { DivbyzeroR :: new (((self . bits >> 25) & 1) != 0) } } impl W { # [doc = "Bit 0 - no description available"] # [inline (always)] # [must_use] pub fn iaccviol (& mut self) -> IaccviolW < CfsrSpec > { IaccviolW :: new (self , 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] # [must_use] pub fn daccviol (& mut self) -> DaccviolW < CfsrSpec > { DaccviolW :: new (self , 1) } # [doc = "Bit 3 - no description available"] # [inline (always)] # [must_use] pub fn munstkerr (& mut self) -> MunstkerrW < CfsrSpec > { MunstkerrW :: new (self , 3) } # [doc = "Bit 4 - no description available"] # [inline (always)] # [must_use] pub fn mstkerr (& mut self) -> MstkerrW < CfsrSpec > { MstkerrW :: new (self , 4) } # [doc = "Bit 5 - no description available"] # [inline (always)] # [must_use] pub fn mlsperr (& mut self) -> MlsperrW < CfsrSpec > { MlsperrW :: new (self , 5) } # [doc = "Bit 7 - no description available"] # [inline (always)] # [must_use] pub fn mmarvalid (& mut self) -> MmarvalidW < CfsrSpec > { MmarvalidW :: new (self , 7) } # [doc = "Bit 8 - no description available"] # [inline (always)] # [must_use] pub fn ibuserr (& mut self) -> IbuserrW < CfsrSpec > { IbuserrW :: new (self , 8) } # [doc = "Bit 9 - no description available"] # [inline (always)] # [must_use] pub fn preciserr (& mut self) -> PreciserrW < CfsrSpec > { PreciserrW :: new (self , 9) } # [doc = "Bit 10 - no description available"] # [inline (always)] # [must_use] pub fn impreciserr (& mut self) -> ImpreciserrW < CfsrSpec > { ImpreciserrW :: new (self , 10) } # [doc = "Bit 11 - no description available"] # [inline (always)] # [must_use] pub fn unstkerr (& mut self) -> UnstkerrW < CfsrSpec > { UnstkerrW :: new (self , 11) } # [doc = "Bit 12 - no description available"] # [inline (always)] # [must_use] pub fn stkerr (& mut self) -> StkerrW < CfsrSpec > { StkerrW :: new (self , 12) } # [doc = "Bit 13 - no description available"] # [inline (always)] # [must_use] pub fn lsperr (& mut self) -> LsperrW < CfsrSpec > { LsperrW :: new (self , 13) } # [doc = "Bit 15 - no description available"] # [inline (always)] # [must_use] pub fn bfarvalid (& mut self) -> BfarvalidW < CfsrSpec > { BfarvalidW :: new (self , 15) } # [doc = "Bit 16 - no description available"] # [inline (always)] # [must_use] pub fn undefinstr (& mut self) -> UndefinstrW < CfsrSpec > { UndefinstrW :: new (self , 16) } # [doc = "Bit 17 - no description available"] # [inline (always)] # [must_use] pub fn invstate (& mut self) -> InvstateW < CfsrSpec > { InvstateW :: new (self , 17) } # [doc = "Bit 18 - no description available"] # [inline (always)] # [must_use] pub fn invpc (& mut self) -> InvpcW < CfsrSpec > { InvpcW :: new (self , 18) } # [doc = "Bit 19 - no description available"] # [inline (always)] # [must_use] pub fn nocp (& mut self) -> NocpW < CfsrSpec > { NocpW :: new (self , 19) } # [doc = "Bit 24 - no description available"] # [inline (always)] # [must_use] pub fn unaligned (& mut self) -> UnalignedW < CfsrSpec > { UnalignedW :: new (self , 24) } # [doc = "Bit 25 - no description available"] # [inline (always)] # [must_use] pub fn divbyzero (& mut self) -> DivbyzeroW < CfsrSpec > { DivbyzeroW :: new (self , 25) } } # [doc = "Configurable Fault Status Registers\n\nYou can [`read`](crate::Reg::read) this register and get [`cfsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfsrSpec ; impl crate :: RegisterSpec for CfsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cfsr::R`](R) reader structure"] impl crate :: Readable for CfsrSpec { } # [doc = "`write(|w| ..)` method takes [`cfsr::W`](W) writer structure"] impl crate :: Writable for CfsrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CFSR to value 0"] impl crate :: Resettable for CfsrSpec { const RESET_VALUE : u32 = 0 ; }