# [doc = "Register `DFSR` reader"] pub type R = crate :: R < DfsrSpec > ; # [doc = "Register `DFSR` writer"] pub type W = crate :: W < DfsrSpec > ; # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Halted { # [doc = "0: No active halt request debug event"] _0 = 0 , # [doc = "1: Halt request debug event active"] _1 = 1 , } impl From < Halted > for bool { # [inline (always)] fn from (variant : Halted) -> Self { variant as u8 != 0 } } # [doc = "Field `HALTED` reader - no description available"] pub type HaltedR = crate :: BitReader < Halted > ; impl HaltedR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Halted { match self . bits { false => Halted :: _0 , true => Halted :: _1 , } } # [doc = "No active halt request debug event"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Halted :: _0 } # [doc = "Halt request debug event active"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Halted :: _1 } } # [doc = "Field `HALTED` writer - no description available"] pub type HaltedW < 'a , REG > = crate :: BitWriter < 'a , REG , Halted > ; impl < 'a , REG > HaltedW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No active halt request debug event"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Halted :: _0) } # [doc = "Halt request debug event active"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Halted :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bkpt { # [doc = "0: No current breakpoint debug event"] _0 = 0 , # [doc = "1: At least one current breakpoint debug event"] _1 = 1 , } impl From < Bkpt > for bool { # [inline (always)] fn from (variant : Bkpt) -> Self { variant as u8 != 0 } } # [doc = "Field `BKPT` reader - no description available"] pub type BkptR = crate :: BitReader < Bkpt > ; impl BkptR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bkpt { match self . bits { false => Bkpt :: _0 , true => Bkpt :: _1 , } } # [doc = "No current breakpoint debug event"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Bkpt :: _0 } # [doc = "At least one current breakpoint debug event"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Bkpt :: _1 } } # [doc = "Field `BKPT` writer - no description available"] pub type BkptW < 'a , REG > = crate :: BitWriter < 'a , REG , Bkpt > ; impl < 'a , REG > BkptW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No current breakpoint debug event"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Bkpt :: _0) } # [doc = "At least one current breakpoint debug event"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Bkpt :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dwttrap { # [doc = "0: No current debug events generated by the DWT"] _0 = 0 , # [doc = "1: At least one current debug event generated by the DWT"] _1 = 1 , } impl From < Dwttrap > for bool { # [inline (always)] fn from (variant : Dwttrap) -> Self { variant as u8 != 0 } } # [doc = "Field `DWTTRAP` reader - no description available"] pub type DwttrapR = crate :: BitReader < Dwttrap > ; impl DwttrapR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dwttrap { match self . bits { false => Dwttrap :: _0 , true => Dwttrap :: _1 , } } # [doc = "No current debug events generated by the DWT"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dwttrap :: _0 } # [doc = "At least one current debug event generated by the DWT"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dwttrap :: _1 } } # [doc = "Field `DWTTRAP` writer - no description available"] pub type DwttrapW < 'a , REG > = crate :: BitWriter < 'a , REG , Dwttrap > ; impl < 'a , REG > DwttrapW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No current debug events generated by the DWT"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dwttrap :: _0) } # [doc = "At least one current debug event generated by the DWT"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dwttrap :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Vcatch { # [doc = "0: No Vector catch triggered"] _0 = 0 , # [doc = "1: Vector catch triggered"] _1 = 1 , } impl From < Vcatch > for bool { # [inline (always)] fn from (variant : Vcatch) -> Self { variant as u8 != 0 } } # [doc = "Field `VCATCH` reader - no description available"] pub type VcatchR = crate :: BitReader < Vcatch > ; impl VcatchR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Vcatch { match self . bits { false => Vcatch :: _0 , true => Vcatch :: _1 , } } # [doc = "No Vector catch triggered"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Vcatch :: _0 } # [doc = "Vector catch triggered"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Vcatch :: _1 } } # [doc = "Field `VCATCH` writer - no description available"] pub type VcatchW < 'a , REG > = crate :: BitWriter < 'a , REG , Vcatch > ; impl < 'a , REG > VcatchW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No Vector catch triggered"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Vcatch :: _0) } # [doc = "Vector catch triggered"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Vcatch :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum External { # [doc = "0: No EDBGRQ debug event"] _0 = 0 , # [doc = "1: EDBGRQ debug event"] _1 = 1 , } impl From < External > for bool { # [inline (always)] fn from (variant : External) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTERNAL` reader - no description available"] pub type ExternalR = crate :: BitReader < External > ; impl ExternalR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> External { match self . bits { false => External :: _0 , true => External :: _1 , } } # [doc = "No EDBGRQ debug event"] # [inline (always)] pub fn is_0 (& self) -> bool { * self == External :: _0 } # [doc = "EDBGRQ debug event"] # [inline (always)] pub fn is_1 (& self) -> bool { * self == External :: _1 } } # [doc = "Field `EXTERNAL` writer - no description available"] pub type ExternalW < 'a , REG > = crate :: BitWriter < 'a , REG , External > ; impl < 'a , REG > ExternalW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No EDBGRQ debug event"] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (External :: _0) } # [doc = "EDBGRQ debug event"] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (External :: _1) } } impl R { # [doc = "Bit 0 - no description available"] # [inline (always)] pub fn halted (& self) -> HaltedR { HaltedR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] pub fn bkpt (& self) -> BkptR { BkptR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - no description available"] # [inline (always)] pub fn dwttrap (& self) -> DwttrapR { DwttrapR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - no description available"] # [inline (always)] pub fn vcatch (& self) -> VcatchR { VcatchR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - no description available"] # [inline (always)] pub fn external (& self) -> ExternalR { ExternalR :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - no description available"] # [inline (always)] # [must_use] pub fn halted (& mut self) -> HaltedW < DfsrSpec > { HaltedW :: new (self , 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] # [must_use] pub fn bkpt (& mut self) -> BkptW < DfsrSpec > { BkptW :: new (self , 1) } # [doc = "Bit 2 - no description available"] # [inline (always)] # [must_use] pub fn dwttrap (& mut self) -> DwttrapW < DfsrSpec > { DwttrapW :: new (self , 2) } # [doc = "Bit 3 - no description available"] # [inline (always)] # [must_use] pub fn vcatch (& mut self) -> VcatchW < DfsrSpec > { VcatchW :: new (self , 3) } # [doc = "Bit 4 - no description available"] # [inline (always)] # [must_use] pub fn external (& mut self) -> ExternalW < DfsrSpec > { ExternalW :: new (self , 4) } } # [doc = "Debug Fault Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dfsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DfsrSpec ; impl crate :: RegisterSpec for DfsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfsr::R`](R) reader structure"] impl crate :: Readable for DfsrSpec { } # [doc = "`write(|w| ..)` method takes [`dfsr::W`](W) writer structure"] impl crate :: Writable for DfsrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFSR to value 0"] impl crate :: Resettable for DfsrSpec { const RESET_VALUE : u32 = 0 ; }