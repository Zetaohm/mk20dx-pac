# [doc = "Register `STCTRLH` reader"] pub type R = crate :: R < StctrlhSpec > ; # [doc = "Register `STCTRLH` writer"] pub type W = crate :: W < StctrlhSpec > ; # [doc = "no description available\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wdogen { # [doc = "0: WDOG is disabled."] _0 = 0 , # [doc = "1: WDOG is enabled."] _1 = 1 , } impl From < Wdogen > for bool { # [inline (always)] fn from (variant : Wdogen) -> Self { variant as u8 != 0 } } # [doc = "Field `WDOGEN` reader - no description available"] pub type WdogenR = crate :: BitReader < Wdogen > ; impl WdogenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wdogen { match self . bits { false => Wdogen :: _0 , true => Wdogen :: _1 , } } # [doc = "WDOG is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Wdogen :: _0 } # [doc = "WDOG is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Wdogen :: _1 } } # [doc = "Field `WDOGEN` writer - no description available"] pub type WdogenW < 'a , REG > = crate :: BitWriter < 'a , REG , Wdogen > ; impl < 'a , REG > WdogenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Wdogen :: _0) } # [doc = "WDOG is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Wdogen :: _1) } } # [doc = "no description available\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Clksrc { # [doc = "0: Dedicated clock source selected as WDOG clock (LPO Oscillator)."] _0 = 0 , # [doc = "1: WDOG clock sourced from alternate clock source."] _1 = 1 , } impl From < Clksrc > for bool { # [inline (always)] fn from (variant : Clksrc) -> Self { variant as u8 != 0 } } # [doc = "Field `CLKSRC` reader - no description available"] pub type ClksrcR = crate :: BitReader < Clksrc > ; impl ClksrcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Clksrc { match self . bits { false => Clksrc :: _0 , true => Clksrc :: _1 , } } # [doc = "Dedicated clock source selected as WDOG clock (LPO Oscillator)."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Clksrc :: _0 } # [doc = "WDOG clock sourced from alternate clock source."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Clksrc :: _1 } } # [doc = "Field `CLKSRC` writer - no description available"] pub type ClksrcW < 'a , REG > = crate :: BitWriter < 'a , REG , Clksrc > ; impl < 'a , REG > ClksrcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Dedicated clock source selected as WDOG clock (LPO Oscillator)."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Clksrc :: _0) } # [doc = "WDOG clock sourced from alternate clock source."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Clksrc :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Irqrsten { # [doc = "0: WDOG time-out generates reset only."] _0 = 0 , # [doc = "1: WDOG time-out initially generates an interrupt. After WCT time, it generates a reset."] _1 = 1 , } impl From < Irqrsten > for bool { # [inline (always)] fn from (variant : Irqrsten) -> Self { variant as u8 != 0 } } # [doc = "Field `IRQRSTEN` reader - no description available"] pub type IrqrstenR = crate :: BitReader < Irqrsten > ; impl IrqrstenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Irqrsten { match self . bits { false => Irqrsten :: _0 , true => Irqrsten :: _1 , } } # [doc = "WDOG time-out generates reset only."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Irqrsten :: _0 } # [doc = "WDOG time-out initially generates an interrupt. After WCT time, it generates a reset."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Irqrsten :: _1 } } # [doc = "Field `IRQRSTEN` writer - no description available"] pub type IrqrstenW < 'a , REG > = crate :: BitWriter < 'a , REG , Irqrsten > ; impl < 'a , REG > IrqrstenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG time-out generates reset only."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Irqrsten :: _0) } # [doc = "WDOG time-out initially generates an interrupt. After WCT time, it generates a reset."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Irqrsten :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Winen { # [doc = "0: Windowing mode is disabled."] _0 = 0 , # [doc = "1: Windowing mode is enabled."] _1 = 1 , } impl From < Winen > for bool { # [inline (always)] fn from (variant : Winen) -> Self { variant as u8 != 0 } } # [doc = "Field `WINEN` reader - no description available"] pub type WinenR = crate :: BitReader < Winen > ; impl WinenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Winen { match self . bits { false => Winen :: _0 , true => Winen :: _1 , } } # [doc = "Windowing mode is disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Winen :: _0 } # [doc = "Windowing mode is enabled."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Winen :: _1 } } # [doc = "Field `WINEN` writer - no description available"] pub type WinenW < 'a , REG > = crate :: BitWriter < 'a , REG , Winen > ; impl < 'a , REG > WinenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Windowing mode is disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Winen :: _0) } # [doc = "Windowing mode is enabled."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Winen :: _1) } } # [doc = "no description available\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Allowupdate { # [doc = "0: No further updates allowed to WDOG write once registers."] _0 = 0 , # [doc = "1: WDOG write once registers can be unlocked for updating."] _1 = 1 , } impl From < Allowupdate > for bool { # [inline (always)] fn from (variant : Allowupdate) -> Self { variant as u8 != 0 } } # [doc = "Field `ALLOWUPDATE` reader - no description available"] pub type AllowupdateR = crate :: BitReader < Allowupdate > ; impl AllowupdateR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Allowupdate { match self . bits { false => Allowupdate :: _0 , true => Allowupdate :: _1 , } } # [doc = "No further updates allowed to WDOG write once registers."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Allowupdate :: _0 } # [doc = "WDOG write once registers can be unlocked for updating."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Allowupdate :: _1 } } # [doc = "Field `ALLOWUPDATE` writer - no description available"] pub type AllowupdateW < 'a , REG > = crate :: BitWriter < 'a , REG , Allowupdate > ; impl < 'a , REG > AllowupdateW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No further updates allowed to WDOG write once registers."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Allowupdate :: _0) } # [doc = "WDOG write once registers can be unlocked for updating."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Allowupdate :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dbgen { # [doc = "0: WDOG is disabled in CPU Debug mode."] _0 = 0 , # [doc = "1: WDOG is enabled in CPU Debug mode."] _1 = 1 , } impl From < Dbgen > for bool { # [inline (always)] fn from (variant : Dbgen) -> Self { variant as u8 != 0 } } # [doc = "Field `DBGEN` reader - no description available"] pub type DbgenR = crate :: BitReader < Dbgen > ; impl DbgenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dbgen { match self . bits { false => Dbgen :: _0 , true => Dbgen :: _1 , } } # [doc = "WDOG is disabled in CPU Debug mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Dbgen :: _0 } # [doc = "WDOG is enabled in CPU Debug mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Dbgen :: _1 } } # [doc = "Field `DBGEN` writer - no description available"] pub type DbgenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dbgen > ; impl < 'a , REG > DbgenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG is disabled in CPU Debug mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dbgen :: _0) } # [doc = "WDOG is enabled in CPU Debug mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dbgen :: _1) } } # [doc = "no description available\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Stopen { # [doc = "0: WDOG is disabled in CPU stop mode."] _0 = 0 , # [doc = "1: WDOG is enabled in CPU stop mode."] _1 = 1 , } impl From < Stopen > for bool { # [inline (always)] fn from (variant : Stopen) -> Self { variant as u8 != 0 } } # [doc = "Field `STOPEN` reader - no description available"] pub type StopenR = crate :: BitReader < Stopen > ; impl StopenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Stopen { match self . bits { false => Stopen :: _0 , true => Stopen :: _1 , } } # [doc = "WDOG is disabled in CPU stop mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Stopen :: _0 } # [doc = "WDOG is enabled in CPU stop mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Stopen :: _1 } } # [doc = "Field `STOPEN` writer - no description available"] pub type StopenW < 'a , REG > = crate :: BitWriter < 'a , REG , Stopen > ; impl < 'a , REG > StopenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG is disabled in CPU stop mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Stopen :: _0) } # [doc = "WDOG is enabled in CPU stop mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Stopen :: _1) } } # [doc = "no description available\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waiten { # [doc = "0: WDOG is disabled in CPU wait mode."] _0 = 0 , # [doc = "1: WDOG is enabled in CPU wait mode."] _1 = 1 , } impl From < Waiten > for bool { # [inline (always)] fn from (variant : Waiten) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITEN` reader - no description available"] pub type WaitenR = crate :: BitReader < Waiten > ; impl WaitenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waiten { match self . bits { false => Waiten :: _0 , true => Waiten :: _1 , } } # [doc = "WDOG is disabled in CPU wait mode."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Waiten :: _0 } # [doc = "WDOG is enabled in CPU wait mode."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Waiten :: _1 } } # [doc = "Field `WAITEN` writer - no description available"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG , Waiten > ; impl < 'a , REG > WaitenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG is disabled in CPU wait mode."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Waiten :: _0) } # [doc = "WDOG is enabled in CPU wait mode."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Waiten :: _1) } } # [doc = "Field `TESTWDOG` reader - no description available"] pub type TestwdogR = crate :: BitReader ; # [doc = "Field `TESTWDOG` writer - no description available"] pub type TestwdogW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Testsel { # [doc = "0: Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test."] _0 = 0 , # [doc = "1: Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL\\[1:0\\]
for testing."] _1 = 1 , } impl From < Testsel > for bool { # [inline (always)] fn from (variant : Testsel) -> Self { variant as u8 != 0 } } # [doc = "Field `TESTSEL` reader - no description available"] pub type TestselR = crate :: BitReader < Testsel > ; impl TestselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Testsel { match self . bits { false => Testsel :: _0 , true => Testsel :: _1 , } } # [doc = "Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Testsel :: _0 } # [doc = "Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL\\[1:0\\]
for testing."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Testsel :: _1 } } # [doc = "Field `TESTSEL` writer - no description available"] pub type TestselW < 'a , REG > = crate :: BitWriter < 'a , REG , Testsel > ; impl < 'a , REG > TestselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Testsel :: _0) } # [doc = "Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL\\[1:0\\]
for testing."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Testsel :: _1) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Bytesel { # [doc = "0: Byte 0 selected"] _00 = 0 , # [doc = "1: Byte 1 selected"] _01 = 1 , # [doc = "2: Byte 2 selected"] _10 = 2 , # [doc = "3: Byte 3 selected"] _11 = 3 , } impl From < Bytesel > for u8 { # [inline (always)] fn from (variant : Bytesel) -> Self { variant as _ } } impl crate :: FieldSpec for Bytesel { type Ux = u8 ; } impl crate :: IsEnum for Bytesel { } # [doc = "Field `BYTESEL` reader - no description available"] pub type ByteselR = crate :: FieldReader < Bytesel > ; impl ByteselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bytesel { match self . bits { 0 => Bytesel :: _00 , 1 => Bytesel :: _01 , 2 => Bytesel :: _10 , 3 => Bytesel :: _11 , _ => unreachable ! () , } } # [doc = "Byte 0 selected"] # [inline (always)] pub fn is_00 (& self) -> bool { * self == Bytesel :: _00 } # [doc = "Byte 1 selected"] # [inline (always)] pub fn is_01 (& self) -> bool { * self == Bytesel :: _01 } # [doc = "Byte 2 selected"] # [inline (always)] pub fn is_10 (& self) -> bool { * self == Bytesel :: _10 } # [doc = "Byte 3 selected"] # [inline (always)] pub fn is_11 (& self) -> bool { * self == Bytesel :: _11 } } # [doc = "Field `BYTESEL` writer - no description available"] pub type ByteselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Bytesel , crate :: Safe > ; impl < 'a , REG > ByteselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Byte 0 selected"] # [inline (always)] pub fn _00 (self) -> & 'a mut crate :: W < REG > { self . variant (Bytesel :: _00) } # [doc = "Byte 1 selected"] # [inline (always)] pub fn _01 (self) -> & 'a mut crate :: W < REG > { self . variant (Bytesel :: _01) } # [doc = "Byte 2 selected"] # [inline (always)] pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Bytesel :: _10) } # [doc = "Byte 3 selected"] # [inline (always)] pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Bytesel :: _11) } } # [doc = "no description available\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Distestwdog { # [doc = "0: WDOG functional test mode is not disabled."] _0 = 0 , # [doc = "1: WDOG functional test mode is disabled permanently until reset."] _1 = 1 , } impl From < Distestwdog > for bool { # [inline (always)] fn from (variant : Distestwdog) -> Self { variant as u8 != 0 } } # [doc = "Field `DISTESTWDOG` reader - no description available"] pub type DistestwdogR = crate :: BitReader < Distestwdog > ; impl DistestwdogR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Distestwdog { match self . bits { false => Distestwdog :: _0 , true => Distestwdog :: _1 , } } # [doc = "WDOG functional test mode is not disabled."] # [inline (always)] pub fn is_0 (& self) -> bool { * self == Distestwdog :: _0 } # [doc = "WDOG functional test mode is disabled permanently until reset."] # [inline (always)] pub fn is_1 (& self) -> bool { * self == Distestwdog :: _1 } } # [doc = "Field `DISTESTWDOG` writer - no description available"] pub type DistestwdogW < 'a , REG > = crate :: BitWriter < 'a , REG , Distestwdog > ; impl < 'a , REG > DistestwdogW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "WDOG functional test mode is not disabled."] # [inline (always)] pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Distestwdog :: _0) } # [doc = "WDOG functional test mode is disabled permanently until reset."] # [inline (always)] pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Distestwdog :: _1) } } impl R { # [doc = "Bit 0 - no description available"] # [inline (always)] pub fn wdogen (& self) -> WdogenR { WdogenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] pub fn clksrc (& self) -> ClksrcR { ClksrcR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - no description available"] # [inline (always)] pub fn irqrsten (& self) -> IrqrstenR { IrqrstenR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - no description available"] # [inline (always)] pub fn winen (& self) -> WinenR { WinenR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - no description available"] # [inline (always)] pub fn allowupdate (& self) -> AllowupdateR { AllowupdateR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - no description available"] # [inline (always)] pub fn dbgen (& self) -> DbgenR { DbgenR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - no description available"] # [inline (always)] pub fn stopen (& self) -> StopenR { StopenR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - no description available"] # [inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 10 - no description available"] # [inline (always)] pub fn testwdog (& self) -> TestwdogR { TestwdogR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - no description available"] # [inline (always)] pub fn testsel (& self) -> TestselR { TestselR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - no description available"] # [inline (always)] pub fn bytesel (& self) -> ByteselR { ByteselR :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bit 14 - no description available"] # [inline (always)] pub fn distestwdog (& self) -> DistestwdogR { DistestwdogR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - no description available"] # [inline (always)] # [must_use] pub fn wdogen (& mut self) -> WdogenW < StctrlhSpec > { WdogenW :: new (self , 0) } # [doc = "Bit 1 - no description available"] # [inline (always)] # [must_use] pub fn clksrc (& mut self) -> ClksrcW < StctrlhSpec > { ClksrcW :: new (self , 1) } # [doc = "Bit 2 - no description available"] # [inline (always)] # [must_use] pub fn irqrsten (& mut self) -> IrqrstenW < StctrlhSpec > { IrqrstenW :: new (self , 2) } # [doc = "Bit 3 - no description available"] # [inline (always)] # [must_use] pub fn winen (& mut self) -> WinenW < StctrlhSpec > { WinenW :: new (self , 3) } # [doc = "Bit 4 - no description available"] # [inline (always)] # [must_use] pub fn allowupdate (& mut self) -> AllowupdateW < StctrlhSpec > { AllowupdateW :: new (self , 4) } # [doc = "Bit 5 - no description available"] # [inline (always)] # [must_use] pub fn dbgen (& mut self) -> DbgenW < StctrlhSpec > { DbgenW :: new (self , 5) } # [doc = "Bit 6 - no description available"] # [inline (always)] # [must_use] pub fn stopen (& mut self) -> StopenW < StctrlhSpec > { StopenW :: new (self , 6) } # [doc = "Bit 7 - no description available"] # [inline (always)] # [must_use] pub fn waiten (& mut self) -> WaitenW < StctrlhSpec > { WaitenW :: new (self , 7) } # [doc = "Bit 10 - no description available"] # [inline (always)] # [must_use] pub fn testwdog (& mut self) -> TestwdogW < StctrlhSpec > { TestwdogW :: new (self , 10) } # [doc = "Bit 11 - no description available"] # [inline (always)] # [must_use] pub fn testsel (& mut self) -> TestselW < StctrlhSpec > { TestselW :: new (self , 11) } # [doc = "Bits 12:13 - no description available"] # [inline (always)] # [must_use] pub fn bytesel (& mut self) -> ByteselW < StctrlhSpec > { ByteselW :: new (self , 12) } # [doc = "Bit 14 - no description available"] # [inline (always)] # [must_use] pub fn distestwdog (& mut self) -> DistestwdogW < StctrlhSpec > { DistestwdogW :: new (self , 14) } } # [doc = "Watchdog Status and Control Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`stctrlh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stctrlh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StctrlhSpec ; impl crate :: RegisterSpec for StctrlhSpec { type Ux = u16 ; } # [doc = "`read()` method returns [`stctrlh::R`](R) reader structure"] impl crate :: Readable for StctrlhSpec { } # [doc = "`write(|w| ..)` method takes [`stctrlh::W`](W) writer structure"] impl crate :: Writable for StctrlhSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets STCTRLH to value 0x01d3"] impl crate :: Resettable for StctrlhSpec { const RESET_VALUE : u16 = 0x01d3 ; }